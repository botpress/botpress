/* eslint-disable jsdoc/check-alignment */
/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Order Fulfillment API
 * For API testing via Postman, ensure your application's scopes are approved, and then click [here](https://god.gw.postman.com/run-collection/6384856-15146fc5-4e59-4f50-85c8-64567630e791?action=collection%2Ffork&source=rip_markdown&collection-url=entityId%3D6384856-15146fc5-4e59-4f50-85c8-64567630e791%26entityType%3Dcollection%26workspaceId%3De5995580-1109-4772-a883-92e9531beae5#?env%5BUber%20Eats%20Marketplace%20API%5D=W3sia2V5IjoidWJlcl9hcGlfY2xpZW50X2lkIiwidmFsdWUiOiIiLCJlbmFibGVkIjp0cnVlLCJzZXNzaW9uVmFsdWUiOiIiLCJzZXNzaW9uSW5kZXgiOjB9LHsia2V5IjoidWJlcl9hcGlfY2xpZW50X3NlY3JldCIsInZhbHVlIjoiIiwiZW5hYmxlZCI6dHJ1ZSwidHlwZSI6InNlY3JldCIsInNlc3Npb25WYWx1ZSI6IiIsInNlc3Npb25JbmRleCI6MX0seyJrZXkiOiJzdG9yZV9pZCIsInZhbHVlIjoiIiwiZW5hYmxlZCI6dHJ1ZSwic2Vzc2lvblZhbHVlIjoiIiwic2Vzc2lvbkluZGV4IjoyfSx7ImtleSI6ImJhc2VfdXJsIiwidmFsdWUiOiJodHRwczovL2FwaS51YmVyLmNvbSIsImVuYWJsZWQiOnRydWUsInR5cGUiOiJkZWZhdWx0Iiwic2Vzc2lvblZhbHVlIjoiaHR0cHM6Ly9hcGkudWJlci5jb20iLCJzZXNzaW9uSW5kZXgiOjN9LHsia2V5IjoiZWF0c19zdG9yZV90b2tlbiIsInZhbHVlIjoiIiwiZW5hYmxlZCI6dHJ1ZSwidHlwZSI6ImFueSIsInNlc3Npb25WYWx1ZSI6IiIsInNlc3Npb25JbmRleCI6NH0seyJrZXkiOiJzY29wZXMiLCJ2YWx1ZSI6IiIsImVuYWJsZWQiOnRydWUsInR5cGUiOiJkZWZhdWx0Iiwic2Vzc2lvblZhbHVlIjoiIiwic2Vzc2lvbkluZGV4Ijo1fSx7ImtleSI6Im9yZGVyX2lkIiwidmFsdWUiOiIiLCJlbmFibGVkIjp0cnVlLCJ0eXBlIjoiZGVmYXVsdCIsInNlc3Npb25WYWx1ZSI6IiIsInNlc3Npb25JbmRleCI6Nn1d)  to fork the collection.

# Table of contents
- [Order Webhooks](#tag/WebhookEvents)
- [Get Order Details](#tag/GetOrder)
- [List Orders Details](#tag/GetOrders)
- [Accept Order](#tag/AcceptOrder)
- [Deny Order](#tag/DenyOrder)
- [Cancel Order](#tag/CancelOrder)
- [Mark Order Ready](#tag/OrderReady)
- [Adjust Order Price](#tag/AdjustOrderPrice)
- [Update Order Ready Time](#tag/UpdateOrderReadyTime)
- [Resolve Fulfillment Issues](#tag/ResolveOrderFulfillmentIssue)

 * OpenAPI spec version: 1.0.0
 */
import axios, { AxiosRequestConfig, AxiosResponse } from 'axios'

export const RestaurantActionType = {
  ASK_CUSTOMER: 'ASK_CUSTOMER',
} as const

export const RetailActionType = {
  SUBSTITUTE_ME: 'SUBSTITUTE_ME',
  REPLACE_FOR_ME: 'REPLACE_FOR_ME',
  REMOVE_ITEM: 'REMOVE_ITEM',
} as const

export const ActionType = { ...RestaurantActionType, ...RetailActionType } as const

export type ActionType = (typeof ActionType)[keyof typeof ActionType]

/**
 * >
Specifies the action type to resolve the fulfillment issue.
| String            |  Description                                                                     |
| ------------------| ---------------------------------------------------------------------------------|
|  `ASK_CUSTOMER`     | Allows merchants to request customers to update their order to resolve fulfillment issues. In the instance where `order.customers.can_respond_to_fulfillment_issues` is `true` customers can choose a specific replacement or remove the affected item. Once the customer responds, a webhook `order.fulfillment_issues.resolved` is sent to the merchant, indicating that the customer has resolved the fulfillment issue. This action is available for "Restaurant" merchants only. |

 */
export type RestaurantActionType = (typeof RestaurantActionType)[keyof typeof RestaurantActionType]

/**
 * >
Specifies the action type to resolve the fulfillment issue in the instance where issue_type is `OUT_OF_ITEM`:

| String             |  Description                                                                     |
| ------------------ | ---------------------------------------------------------------------------------|
|  `SUBSTITUTE_ME`    | Allows merchant to replace an item with customer's specific replacement preference. This action should only be used when the customer's preferred action is `SUBSTITUTE_ME` and  it's available for "Retail" merchants only.                               |
|  `REPLACE_FOR_ME`    | Allows merchant to choose a replacement to send to the customers. If "Replacement Tracking & Approvals" (RT&A) is enabled, it allows customers to approve or reject replacement suggestions. If RT&A is not enabled (default configuration), the substitution is approved automatically. This action is available for "Retail" merchants only. |
|  `REMOVE_ITEM`       | Allows merchant to remove an item if it's unavailable. This action is available for "Retail" merchants only.  |

 */
export type RetailActionType = (typeof RetailActionType)[keyof typeof RetailActionType]

/**
 * Details of the store.
 */
export type Store = {
  /** Unique identifier of the store. */
  id?: string
  /** Name of the store */
  name?: string
  partner_identifiers?: PartnerIdentifiers[]
  /** Uber's internal standardized categorization of merchants. */
  uber_merchant_type?: UberMerchantType
}

/**
 * Uber's internal standardized categorization of merchants.
 */
export type UberMerchantTypeType = (typeof UberMerchantTypeType)[keyof typeof UberMerchantTypeType]

export const UberMerchantTypeType = {
  MERCHANT_TYPE_UNKNOWN: 'MERCHANT_TYPE_UNKNOWN',
  MERCHANT_TYPE_RESTAURANT: 'MERCHANT_TYPE_RESTAURANT',
  MERCHANT_TYPE_GROCERY: 'MERCHANT_TYPE_GROCERY',
  MERCHANT_TYPE_LIQUOR: 'MERCHANT_TYPE_LIQUOR',
  MERCHANT_TYPE_SPECIALTY_FOOD: 'MERCHANT_TYPE_SPECIALTY_FOOD',
  MERCHANT_TYPE_CONVENIENCE: 'MERCHANT_TYPE_CONVENIENCE',
  MERCHANT_TYPE_PHARMACY: 'MERCHANT_TYPE_PHARMACY',
  MERCHANT_TYPE_FLORIST: 'MERCHANT_TYPE_FLORIST',
  MERCHANT_TYPE_PET_SUPPLY: 'MERCHANT_TYPE_PET_SUPPLY',
  MERCHANT_TYPE_RETAIL: 'MERCHANT_TYPE_RETAIL',
  MERCHANT_TYPE_VIRTUAL_RESTAURANT: 'MERCHANT_TYPE_VIRTUAL_RESTAURANT',
} as const

export type UberMerchantType = {
  /** Uber's internal standardized categorization of merchants. */
  type?: UberMerchantTypeType
}

/**
 * The type of the identifier.
 */
export type PartnerIdentifiersType = (typeof PartnerIdentifiersType)[keyof typeof PartnerIdentifiersType]

export const PartnerIdentifiersType = {
  MERCHANT_STORE_ID: 'MERCHANT_STORE_ID',
  INTEGRATOR_STORE_ID: 'INTEGRATOR_STORE_ID',
  INTEGRATOR_BRAND_ID: 'INTEGRATOR_BRAND_ID',
  ORDER_MANAGER_CLIENT_ID: 'ORDER_MANAGER_CLIENT_ID',
} as const

export type PartnerIdentifiers = {
  /** A unique identifier for the partner. */
  value?: string
  /** The type of the identifier. */
  type?: PartnerIdentifiersType
}

export type QuantityUnit = (typeof QuantityUnit)[keyof typeof QuantityUnit]

export const QuantityUnit = {
  POUND: 'POUND',
  PIECE: 'PIECE',
  KILOGRAM: 'KILOGRAM',
  GRAM: 'GRAM',
} as const

export type Quantity = {
  amount?: number
  unit?: QuantityUnit
}

/**
 * The type of measurement type, which can be a physical dimension (weight), or whole number based system.
 */
export type QuantityPIWInSellableUnitMeasurementUnitMeasurementType =
  (typeof QuantityPIWInSellableUnitMeasurementUnitMeasurementType)[keyof typeof QuantityPIWInSellableUnitMeasurementUnitMeasurementType]

export const QuantityPIWInSellableUnitMeasurementUnitMeasurementType = {
  MEASUREMENT_TYPE_COUNT: 'MEASUREMENT_TYPE_COUNT',
  MEASUREMENT_TYPE_WEIGHT: 'MEASUREMENT_TYPE_WEIGHT',
} as const

/**
 * The weight unit type that is being used for the item.
 */
export type QuantityPIWInSellableUnitMeasurementUnitWeightUnitType =
  (typeof QuantityPIWInSellableUnitMeasurementUnitWeightUnitType)[keyof typeof QuantityPIWInSellableUnitMeasurementUnitWeightUnitType]

export const QuantityPIWInSellableUnitMeasurementUnitWeightUnitType = {
  WEIGHT_UNIT_TYPE_METRIC_GRAM: 'WEIGHT_UNIT_TYPE_METRIC_GRAM',
  WEIGHT_UNIT_TYPE_METRIC_KILOGRAM: 'WEIGHT_UNIT_TYPE_METRIC_KILOGRAM',
  WEIGHT_UNIT_TYPE_IMPERIAL_ONCE: 'WEIGHT_UNIT_TYPE_IMPERIAL_ONCE',
  WEIGHT_UNIT_TYPE_IMPERIAL_POUND: 'WEIGHT_UNIT_TYPE_IMPERIAL_POUND',
} as const

/**
 * Description of the weight of the item, if the measurement type is MEASUREMENT_TYPE_WEIGHT
 */
export type QuantityPIWInSellableUnitMeasurementUnitWeight = {
  /** The weight unit type that is being used for the item. */
  unit_type?: QuantityPIWInSellableUnitMeasurementUnitWeightUnitType
}

/**
 * Unit in which the quantity is measured with. "Kg", "Lb", "Un", "Meter", etc.
 */
export type QuantityPIWInSellableUnitMeasurementUnit = {
  /** The type of measurement type, which can be a physical dimension (weight), or whole number based system. */
  measurement_type?: QuantityPIWInSellableUnitMeasurementUnitMeasurementType
  /** Description of the weight of the item, if the measurement type is MEASUREMENT_TYPE_WEIGHT */
  weight?: QuantityPIWInSellableUnitMeasurementUnitWeight
}

/**
 * Represents the quantity of a cart item in the units that were already presented to the customer
 */
export type QuantityPIWInSellableUnit = {
  /** Unit in which the quantity is measured with. "Kg", "Lb", "Un", "Meter", etc. */
  measurement_unit?: QuantityPIWInSellableUnitMeasurementUnit
  /** Numeric value of the quantity. It is based on the measurement unit and it is in E5 format. Eg for 2.1 lb of an item, the amount would be 21000 in E5, based on the formula X * 10^5 */
  amount_e5?: number
}

export type QuantityPIWInPriceableUnitMeasurementUnitMeasurementType =
  (typeof QuantityPIWInPriceableUnitMeasurementUnitMeasurementType)[keyof typeof QuantityPIWInPriceableUnitMeasurementUnitMeasurementType]

export const QuantityPIWInPriceableUnitMeasurementUnitMeasurementType = {
  MEASUREMENT_TYPE_COUNT: 'MEASUREMENT_TYPE_COUNT',
  MEASUREMENT_TYPE_WEIGHT: 'MEASUREMENT_TYPE_WEIGHT',
} as const

/**
 * The weight unit type that is being used for the item.
 */
export type QuantityPIWInPriceableUnitMeasurementUnitWeightUnitType =
  (typeof QuantityPIWInPriceableUnitMeasurementUnitWeightUnitType)[keyof typeof QuantityPIWInPriceableUnitMeasurementUnitWeightUnitType]

export const QuantityPIWInPriceableUnitMeasurementUnitWeightUnitType = {
  WEIGHT_UNIT_TYPE_METRIC_GRAM: 'WEIGHT_UNIT_TYPE_METRIC_GRAM',
  WEIGHT_UNIT_TYPE_METRIC_KILOGRAM: 'WEIGHT_UNIT_TYPE_METRIC_KILOGRAM',
  WEIGHT_UNIT_TYPE_IMPERIAL_ONCE: 'WEIGHT_UNIT_TYPE_IMPERIAL_ONCE',
  WEIGHT_UNIT_TYPE_IMPERIAL_POUND: 'WEIGHT_UNIT_TYPE_IMPERIAL_POUND',
} as const

/**
 * Description of the weight of the item, if the measurement type is MEASUREMENT_TYPE_WEIGHT
 */
export type QuantityPIWInPriceableUnitMeasurementUnitWeight = {
  /** The weight unit type that is being used for the item. */
  unit_type?: QuantityPIWInPriceableUnitMeasurementUnitWeightUnitType
}

/**
 * Unit in which the quantity is measured with. "Kg", "Lb", "Un", "Meter", etc.
 */
export type QuantityPIWInPriceableUnitMeasurementUnit = {
  measurement_type?: QuantityPIWInPriceableUnitMeasurementUnitMeasurementType
  /** Description of the weight of the item, if the measurement type is MEASUREMENT_TYPE_WEIGHT */
  weight?: QuantityPIWInPriceableUnitMeasurementUnitWeight
}

/**
 * Represents the quantity of a cart item in the priceable unit at the store. Not necessarily the same as what the customer added.
 */
export type QuantityPIWInPriceableUnit = {
  /** Unit in which the quantity is measured with. "Kg", "Lb", "Un", "Meter", etc. */
  measurement_unit?: QuantityPIWInPriceableUnitMeasurementUnit
  /** Numeric value of the quantity. It is based on the measurement unit and it is in E5 format. Eg for 2.1 lb of an item, the amount would be 21000 in E5, based on the formula X * 10^5 */
  amount_e5?: number
}

export type QuantityPIW = {
  amount?: number
  /** Represents the quantity of a cart item in the units that were already presented to the customer */
  in_sellable_unit?: QuantityPIWInSellableUnit
  /** Represents the quantity of a cart item in the priceable unit at the store. Not necessarily the same as what the customer added. */
  in_priceable_unit?: QuantityPIWInPriceableUnit
}

/**
 * The type of measurement type, which can be a physical dimension (weight), or whole number based system.
 */
export type PiwInSellableUnitMeasurementUnitMeasurementType =
  (typeof PiwInSellableUnitMeasurementUnitMeasurementType)[keyof typeof PiwInSellableUnitMeasurementUnitMeasurementType]

export const PiwInSellableUnitMeasurementUnitMeasurementType = {
  MEASUREMENT_TYPE_COUNT: 'MEASUREMENT_TYPE_COUNT',
  MEASUREMENT_TYPE_WEIGHT: 'MEASUREMENT_TYPE_WEIGHT',
} as const

/**
 * The weight unit type that is being used for the item.
 */
export type PiwInSellableUnitMeasurementUnitWeightUnitType =
  (typeof PiwInSellableUnitMeasurementUnitWeightUnitType)[keyof typeof PiwInSellableUnitMeasurementUnitWeightUnitType]

export const PiwInSellableUnitMeasurementUnitWeightUnitType = {
  WEIGHT_UNIT_TYPE_METRIC_GRAM: 'WEIGHT_UNIT_TYPE_METRIC_GRAM',
  WEIGHT_UNIT_TYPE_METRIC_KILOGRAM: 'WEIGHT_UNIT_TYPE_METRIC_KILOGRAM',
  WEIGHT_UNIT_TYPE_IMPERIAL_ONCE: 'WEIGHT_UNIT_TYPE_IMPERIAL_ONCE',
  WEIGHT_UNIT_TYPE_IMPERIAL_POUND: 'WEIGHT_UNIT_TYPE_IMPERIAL_POUND',
} as const

/**
 * Description of the weight of the item, if the measurement type is MEASUREMENT_TYPE_WEIGHT
 */
export type PiwInSellableUnitMeasurementUnitWeight = {
  /** The weight unit type that is being used for the item. */
  unit_type?: PiwInSellableUnitMeasurementUnitWeightUnitType
}

/**
 * Unit in which the quantity is measured with. "Kg", "Lb", "Un", "Meter", etc.
 */
export type PiwInSellableUnitMeasurementUnit = {
  /** The type of measurement type, which can be a physical dimension (weight), or whole number based system. */
  measurement_type?: PiwInSellableUnitMeasurementUnitMeasurementType
  /** Description of the weight of the item, if the measurement type is MEASUREMENT_TYPE_WEIGHT */
  weight?: PiwInSellableUnitMeasurementUnitWeight
}

/**
 * Represents the quantity of a cart item in the units that were already presented to the customer
 */
export type PiwInSellableUnit = {
  /** Unit in which the quantity is measured with. "Kg", "Lb", "Un", "Meter", etc. */
  measurement_unit?: PiwInSellableUnitMeasurementUnit
  /** Numeric value of the quantity. It is based on the measurement unit and it is in E5 format. Eg for 2.1 lb of an item, the amount would be 21000 in E5, based on the formula X * 10^5 */
  amount_e5?: number
}

export type PiwInPriceableUnitMeasurementUnitMeasurementType =
  (typeof PiwInPriceableUnitMeasurementUnitMeasurementType)[keyof typeof PiwInPriceableUnitMeasurementUnitMeasurementType]

export const PiwInPriceableUnitMeasurementUnitMeasurementType = {
  MEASUREMENT_TYPE_COUNT: 'MEASUREMENT_TYPE_COUNT',
  MEASUREMENT_TYPE_WEIGHT: 'MEASUREMENT_TYPE_WEIGHT',
} as const

/**
 * The weight unit type that is being used for the item.
 */
export type PiwInPriceableUnitMeasurementUnitWeightUnitType =
  (typeof PiwInPriceableUnitMeasurementUnitWeightUnitType)[keyof typeof PiwInPriceableUnitMeasurementUnitWeightUnitType]

export const PiwInPriceableUnitMeasurementUnitWeightUnitType = {
  WEIGHT_UNIT_TYPE_METRIC_GRAM: 'WEIGHT_UNIT_TYPE_METRIC_GRAM',
  WEIGHT_UNIT_TYPE_METRIC_KILOGRAM: 'WEIGHT_UNIT_TYPE_METRIC_KILOGRAM',
  WEIGHT_UNIT_TYPE_IMPERIAL_ONCE: 'WEIGHT_UNIT_TYPE_IMPERIAL_ONCE',
  WEIGHT_UNIT_TYPE_IMPERIAL_POUND: 'WEIGHT_UNIT_TYPE_IMPERIAL_POUND',
} as const

/**
 * Description of the weight of the item, if the measurement type is MEASUREMENT_TYPE_WEIGHT
 */
export type PiwInPriceableUnitMeasurementUnitWeight = {
  /** The weight unit type that is being used for the item. */
  unit_type?: PiwInPriceableUnitMeasurementUnitWeightUnitType
}

/**
 * Unit in which the quantity is measured with. "Kg", "Lb", "Un", "Meter", etc.
 */
export type PiwInPriceableUnitMeasurementUnit = {
  measurement_type?: PiwInPriceableUnitMeasurementUnitMeasurementType
  /** Description of the weight of the item, if the measurement type is MEASUREMENT_TYPE_WEIGHT */
  weight?: PiwInPriceableUnitMeasurementUnitWeight
}

/**
 * Represents the quantity of a cart item in the priceable unit at the store. Not necessarily the same as what the customer added.
 */
export type PiwInPriceableUnit = {
  /** Unit in which the quantity is measured with. "Kg", "Lb", "Un", "Meter", etc. */
  measurement_unit?: PiwInPriceableUnitMeasurementUnit
  /** Numeric value of the quantity. It is based on the measurement unit and it is in E5 format. Eg for 2.1 lb of an item, the amount would be 21000 in E5, based on the formula X * 10^5 */
  amount_e5?: number
}

export type Piw = {
  amount?: number
  /** Represents the quantity of a cart item in the units that were already presented to the customer */
  in_sellable_unit?: PiwInSellableUnit
  /** Represents the quantity of a cart item in the priceable unit at the store. Not necessarily the same as what the customer added. */
  in_priceable_unit?: PiwInPriceableUnit
}

/**
 * Timestamp in RFC3339 format. Available for scheduled orders only. The customer-specified time of when they prefer the order to be delivered.
 */
export type TimeRange = {
  start_time?: string
  end_time?: string
}

export type Item = {
  id?: ItemId
  cart_item_id?: CartItemId
  customer_id?: CustomerId
  title?: ItemTitle
  /** Free form string field that permits data provided by the Partner to be sent back. */
  external_data?: string
  quantity?: QuantityPIW
  default_quantity?: Quantity
  customer_request?: CustomerRequest
  selected_modifier_groups?: SelectedModifierGroups[]
  picture_url?: ItemPictureUrl
  fulfillment_action?: FulfillmentIssueAction
}

/**
 * The name of the item on Uber.
 */
export type ItemTitle = string

/**
 * An external identifier, provided by the Partner or generated by Uber.
 */
export type ItemId = string

/**
 * The shopping cart item ID. It refers to the specific line item in the cart.
 */
export type CartItemId = string

/**
 * The Customer ID that this item is for.
 */
export type CustomerId = string

/**
 * A link to the image of the item.
 */
export type ItemPictureUrl = string

/**
 * The item affected by the fulfillment issue.
 */
export type RootItem = {
  cart_item_id?: CartItemId
}

export type ItemSubstitutes = {
  id?: ItemId
  title?: ItemTitle
}

/**
 * The item to be substituted in the instance where `action_type` is `SUBSTITUTE_ME` or `REPLACE_FOR_ME`.
 */
export type ItemSubstitute = {
  id?: ItemId
  quantity?: Piw
}

/**
 * Time and date to set this item out of stock in RFC3339 format.
 */
export type SuspendUntil = string

/**
 * Free form response from restaurant explaining why there was a fulfillment issue.
 */
export type StoreResponse = string

/**
 * The item affected by the fulfillment issue.
 */
export type FulfillmentIssueItem = {
  id?: ItemId
  cart_item_id?: CartItemId
  customer_id?: CustomerId
  title?: ItemTitle
  quantity?: Quantity
  picture_url?: ItemPictureUrl
}

/**
 * Provides the preferences selected by the customer in case the item is unavailable.
 */
export type FulfillmentIssueAction = {
  action_type?: RetailActionType
  /** Array of items to be substituted in the instance where customer's specific replacement preference `action_type` is `SUBSTITUTE_ME`. */
  item_substitutes?: ItemSubstitutes[]
}

export type SelectedModifierGroups = {
  /** The identifier of the modifier group provided by the Merchant. */
  id?: string
  /** The name of the modifier group. */
  title?: string
  /** Free text metadata for the modifier group. */
  external_data?: string
  /** Items that were selected as options in this modifier group. */
  selected_items?: Item[]
  /** Items that were removed as options in this modifier group. */
  removed_items?: Item[]
}

export type OrdersScheduledNotificationMeta = {
  user_id?: string
  resource_id?: string
  status?: Status
}

/**
 * Payload for scheduled order notifications. This event is only triggered if you are at minimum the API version 1.0. The resource_href is determined based on the API version set within [Integration Configuration](/docs/eats/references/api/integration_activation_suite)
 */
export type OrdersScheduledNotification = {
  event_id?: string
  event_type?: string
  event_time?: EventTime
  resource_href?: string
  meta?: OrdersScheduledNotificationMeta
  webhook_meta?: WebhookMeta
}

export type OrdersNotificationMeta = {
  user_id?: string
  resource_id?: string
  status?: Status
}

/**
 * Payload for order notifications. The resource_href is determined based on the API version set within [Integration Configuration](/docs/eats/references/api/integration_activation_suite)
 */
export type OrdersNotification = {
  event_id?: string
  event_type?: string
  event_time?: EventTime
  resource_href?: string
  meta?: OrdersNotificationMeta
  webhook_meta?: WebhookMeta
}

export type OrdersReleaseMeta = {
  user_id?: string
  resource_id?: string
  status?: Status
}

/**
 * Notification that is passed when a courier has reach a predetermined geo-fence from the location. Note that these must be enabled via the [Integration Configuration API](/docs/eats/references/api/integration_activation_suite).
 */
export type OrdersRelease = {
  event_id?: string
  event_type?: string
  event_time?: EventTime
  resource_href?: string
  meta?: OrdersReleaseMeta
  webhook_meta?: WebhookMeta
}

export type OrdersFailureMeta = {
  user_id?: string
  resource_id?: string
  status?: Status
}

/**
 * Notification for failed orders. Note that this is passed as soon as an order is failed, you may experience and error if there is an immediate request to retrieve the order details.
 */
export type OrdersFailure = {
  event_id?: string
  event_type?: string
  event_time?: EventTime
  resource_href?: string
  meta?: OrdersFailureMeta
  webhook_meta?: WebhookMeta
}

export type OrdersFulfillmentIssuesResolvedMeta = {
  user_id?: string
  resource_id?: string
  status?: Status
}

/**
 * Notification event when fulfillment issues are resolved by the customer on Uber's end. This event is triggered when Resolve for Fulfillment endpoint is called or when a user is informed of a fulfillment issue by any means.
 */
export type OrdersFulfillmentIssuesResolved = {
  event_id?: string
  event_type?: string
  event_time?: EventTime
  resource_href?: string
  meta?: OrdersFulfillmentIssuesResolvedMeta
  webhook_meta?: WebhookMeta
}

export type DeliveryStateChangedMetaStatus =
  (typeof DeliveryStateChangedMetaStatus)[keyof typeof DeliveryStateChangedMetaStatus]

export const DeliveryStateChangedMetaStatus = {
  SCHEDULED: 'SCHEDULED',
  EN_ROUTE_TO_PICKUP: 'EN_ROUTE_TO_PICKUP',
  ARRIVED_AT_PICKUP: 'ARRIVED_AT_PICKUP',
  EN_ROUTE_TO_DROPOFF: 'EN_ROUTE_TO_DROPOFF',
  ARRIVED_AT_DROPOFF: 'ARRIVED_AT_DROPOFF',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
} as const

export type DeliveryStateChangedMeta = {
  courier_trip_id?: string
  store_id?: string
  order_id?: string
  external_order_id?: string
  status?: DeliveryStateChangedMetaStatus
}

export type DeliveryStateChanged = {
  event_id?: string
  event_type?: string
  event_time?: EventTime
  resource_href?: string
  meta?: DeliveryStateChangedMeta
  webhook_meta?: WebhookMeta
}

export type Status = string

export type EventTime = number

export type WebhookMeta = {
  client_id?: string
  webhook_config_id?: string
  webhook_msg_timestamp?: number
  webhook_msg_uuid?: string
}

/**
 * List of customers associated with the order.
 */
export type OrderCustomer = Customer[]

/**
 * The contact details of a Customer.
 */
export type CustomerContact = {
  phone?: Phone
}

export type Customer = {
  /** Unique identifier of the customer. */
  id?: string
  name?: Name
  order_history?: OrderHistory
  /** The contact details of a Customer. */
  contact?: CustomerContact
  /** In a group order, indicates if this is the customer who created the order. */
  is_primary_customer?: boolean
  /** The customer tax profile information. */
  tax_profiles?: TaxProfiles[]
  /** Indicates whether a customer can respond to revise fulfillment issues. */
  can_respond_to_fulfillment_issues?: boolean
}

export type CustomerRequest = {
  /** Metadata on allergens selected by the Customer. */
  allergy?: Allergy
  /** Item level instructions provided by the Customer. */
  special_instructions?: string
}

export type Allergy = {
  /** A selected list of allergens. Common enumerated allergens include but are not limited to - DAIRY, EGG, FISH, PEANUTS */
  allergens?: string[]
  /** Customer entered free text related to allergens. */
  instructions?: string
}

/**
 * The type of tax identifier.
 */
export type TaxProfilesTaxIdType = (typeof TaxProfilesTaxIdType)[keyof typeof TaxProfilesTaxIdType]

export const TaxProfilesTaxIdType = {
  NIF: 'NIF',
  CPF: 'CPF',
  CORPORATE_TAX_ID: 'CORPORATE_TAX_ID',
  NIP: 'NIP',
  'twn-vat': 'twn-vat',
} as const

/**
 * Additional metadata for the tax profile.
 */
export type TaxProfilesTaxProfileMetadata = {
  /** (Taiwan market only) Mobile barcode. */
  mobile_barcode?: string
  /** (Taiwan market only) Citizen digital certificate. */
  digital_certificate_code?: string
  /** (Taiwan market only) Donation code. */
  donation_code?: string
}

export type TaxProfiles = {
  /** The taxpayer identifier number. It is an identifier that tax authorities use (i.e. IRS) to identify a taxpayer, be it an individual or a business entity. */
  tax_id?: string
  /** The type of tax identifier. */
  tax_id_type?: TaxProfilesTaxIdType
  /** The full name of the Customer for Tax Reporting Purposes. */
  customer_full_name?: string
  /** The email contact for the Customer. */
  email?: string
  /** The legal entity for the tax profile. */
  legal_entity_name?: string
  /** The billing address of the entity. */
  billing_address?: string
  /** The country for the tax profile. */
  country?: string
  /** Additional metadata for the tax profile. */
  tax_profile_metadata?: TaxProfilesTaxProfileMetadata
  /** The encrypted tax identifier. */
  encrypted_tax_id?: EncryptedData
}

export type EncryptedData = {
  /** The encrypted data key. */
  key?: string
  /** The cipher text for the data. */
  cipher_text?: string
}

/**
 * The phone number of the Customer or Delivery Partner.
 */
export type Phone = {
  /** The phone number of the Customer or Delivery Partner. */
  number?: string
  /** The code to enter when the phone number is anonymized. */
  pin_code?: string
  /** Country ISO code of the phone number */
  country_iso2?: string
}

/**
 * Order history of the customer
 */
export type OrderHistory = {
  /** The number of times that a Customer has ordered from the given location. */
  past_order_count?: number
}

/**
 * The name details for the Customer or Delivery Partner.
 */
export type Name = {
  /** The display name of the Customer or Delivery Partner. */
  display_name?: string
  /** The given name of the Customer or Delivery Partner. */
  first_name?: string
  /** The surname or last name of the Customer or Delivery Partner. */
  last_name?: string
}

/**
 * List of deliveries associated with the order. This field is not available for a completed order.
 */
export type OrderDelivery = Delivery[]

/**
 * The current state of the delivery
 */
export type DeliveryStatus = (typeof DeliveryStatus)[keyof typeof DeliveryStatus]

export const DeliveryStatus = {
  SCHEDULED: 'SCHEDULED',
  EN_ROUTE_TO_PICKUP: 'EN_ROUTE_TO_PICKUP',
  ARRIVED_AT_PICKUP: 'ARRIVED_AT_PICKUP',
  EN_ROUTE_TO_DROPOFF: 'EN_ROUTE_TO_DROPOFF',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
} as const

/**
 * Interaction type of the delivery
 */
export type DeliveryInteractionType = (typeof DeliveryInteractionType)[keyof typeof DeliveryInteractionType]

export const DeliveryInteractionType = {
  DOOR_TO_DOOR: 'DOOR_TO_DOOR',
  CURBSIDE: 'CURBSIDE',
  LEAVE_AT_DOOR: 'LEAVE_AT_DOOR',
  DELIVER_TO_DOOR: 'DELIVER_TO_DOOR',
} as const

export type Delivery = {
  /** Unique identifier of the delivery */
  id?: string
  delivery_partner?: DeliveryPartner
  /** The current state of the delivery */
  status?: DeliveryStatus
  location?: Location
  /** Timestamp in RFC3339 format. The estimated time at which the order will be picked up */
  estimated_pick_up_time?: string
  /** Interaction type of the delivery */
  interaction_type?: DeliveryInteractionType
  /** Timestamp in RFC3339 format. Timestamp of when a delivery partner marks an order as not ready */
  delivery_partner_marked_not_ready_time?: string
  /** Timestamp in RFC3339 format. The estimated time at which the order will be dropped off */
  estimated_dropoff_time?: string
  /** Delivery instructions provided to the partner. */
  instructions?: string
}

/**
 * Indicates which location field will be provided.
 */
export type LocationType = (typeof LocationType)[keyof typeof LocationType]

export const LocationType = {
  STREET_ADDRESS: 'STREET_ADDRESS',
  GOOGLE_PLACE: 'GOOGLE_PLACE',
} as const

/**
 * Details relating to the geographical location for a delivery to be fulfilled. This is typically only populated when a merchant is set handle Bring-Your-Own-Courier ("BYOC") orders. For all other fulfillment types, like "DELIVERY_BY_UBER", this object is omitted.
 */
export type Location = {
  /** Indicates which location field will be provided. */
  type?: LocationType
  /** Unique identifier of the location. */
  id?: string
  /** First line of street address of the location. */
  street_address_line_one?: string
  /** Second line of street address of the location. */
  street_address_line_two?: string
  /** The latitude for the location. */
  latitude?: string
  /** The longitude for the location. */
  longitude?: string
  /** The apartment number or suite, if provided. */
  unit_number?: string
  /** Name of the building or business, if provided. */
  business_name?: string
  /** The city code of the location. */
  city?: string
  /** The country code of the location. */
  country?: string
  /** The postal code of the location. */
  postal_code?: string
  /** A unique identifier for the location in the Google Places database. Will only be provided when type = GOOGLE_PLACE. The value that accompanies the location type constant. The current use case for this is to provide the Google Places ID back to the client. This value is used as input to the Google Maps (Places) API to retrieve the location details for the order. It essentially functions as a means to use Google Maps API data instead of Uber provided address details. */
  location_type_value?: string
  /** The first line address as provided by the client. The current use case for this is to provide the first line address as entered by the customer (i.e. eater). This differs from street_address_line_one in the same struct as the field is usually resolved rather than manually inputted. */
  client_provided_street_address_line_one?: string
}

export type DeliveryPartnerName = {
  display_name?: string
}

export type DeliveryPartnerContactPhone = {
  country_iso2?: string
  number?: string
  /** The pin code to access the anonymized phone number. */
  pin_code?: string
}

export type DeliveryPartnerContact = {
  phone?: DeliveryPartnerContactPhone
}

/**
 * Delivery partner information
 */
export type DeliveryPartner = {
  /** A unique identifier for the delivery Partner. */
  id?: string
  name?: DeliveryPartnerName
  vehicle?: Vehicle
  /** A URL that provides a link to an image of the Delivery Partner. */
  picture_url?: string
  contact?: DeliveryPartnerContact
  current_location?: DeliveryPartnerLocation
}

/**
 * Location of the delivery partner
 */
export type DeliveryPartnerLocation = {
  /** Latitude of the current location of the delivery partner. */
  latitude?: string
  /** Longitude of the current location of the delivery partner. */
  longitude?: string
}

/**
 * The type of modality.
 */
export type VehicleType = (typeof VehicleType)[keyof typeof VehicleType]

export const VehicleType = {
  CAR: 'CAR',
  BICYCLE: 'BICYCLE',
  MOTORBIKE: 'MOTORBIKE',
  PEDESTRIAN: 'PEDESTRIAN',
} as const

/**
 * Information about the vehicle of the Delivery Partner
 */
export type Vehicle = {
  /** The type of modality. */
  type?: VehicleType
  /** The make of a vehicle. */
  make?: string
  /** The model of the vehicle. */
  model?: string
  /** The color of the vehicle. */
  color?: string
  /** The licence plate of the vehicle, if applicable. */
  license_plate?: string
  /** (Autonomous delivery only) Indicates if this delivery is via autonomous vehicle. */
  is_autonomous?: boolean
  /** (Autonomous delivery only) Instructions for merchant to put the order in the autonomous vehicle. */
  hand_off_instructions?: string
  /** (Autonomous delivery only) Passcode to open the compartment of the autonomous vehicle. */
  pass_code?: string
}

export type RestaurantShoppingCart = {
  /** The unique identifier that represents the shopping cart. */
  id?: string
  items?: Item[]
  fulfillment_issues?: RestaurantFulfillmentIssue[]
  /** Order level instructions. */
  special_instructions?: string
  /** A flag that indicates whether single use items are to be included with the order. */
  include_single_use_items?: boolean
  /** An identifier that represents the version of the shopping cart. */
  revision_id?: string
  restricted_items?: RestrictedItems
}

export type RetailShoppingCart = {
  /** The unique identifier that represents the shopping cart. */
  id?: string
  items?: Item[]
  fulfillment_issues?: RetailFulfillmentIssue[]
  /** Order level instructions. */
  special_instructions?: string
  /** A flag that indicates whether single use items are to be included with the order. */
  include_single_use_items?: boolean
  /** An identifier that represents the version of the shopping cart. */
  revision_id?: string
  restricted_items?: RestrictedItems
}

/**
 * The type of fulfillment issue.
 */
export type RestaurantIssueType = (typeof RestaurantIssueType)[keyof typeof RestaurantIssueType]

export const RestaurantIssueType = {
  OUT_OF_ITEM: 'OUT_OF_ITEM',
  OUT_OF_MODIFIER_OPTION: 'OUT_OF_MODIFIER_OPTION',
  CANNOT_FULFILL_ALLERGY_REQUEST: 'CANNOT_FULFILL_ALLERGY_REQUEST',
  CANNOT_FULFILL_MERCHANT_INSTRUCTION: 'CANNOT_FULFILL_MERCHANT_INSTRUCTION',
} as const

/**
 * >
The type of fulfillment issues :

| String             |  Description                                                                     |
| ------------------ | ---------------------------------------------------------------------------------|
|  `OUT_OF_ITEM`     | The requested item was not found. Please refer to the `action_type` details below. |
|  `PARTIAL_AVAILABILITY`    | The requested item was found, but not in quantity enough to fulfill the order. No `action_type` is required. |
|  `FOUND_ITEM`     | Item was found and in enough quantity to fulfill the order. No `action_type` is required. |

 */
export type RetailIssueType = (typeof RetailIssueType)[keyof typeof RetailIssueType]

export const RetailIssueType = {
  OUT_OF_ITEM: 'OUT_OF_ITEM',
  PARTIAL_AVAILABILITY: 'PARTIAL_AVAILABILITY',
  FOUND_ITEM: 'FOUND_ITEM',
} as const

/**
 * Specifies the customer acknowledgment type required for a replacement including the customer‚Äôs response. This field is only populated for ‚ÄúRetail‚Äù merchants only.
| String | Description |
| ------ | ----- |
| `ACK_DISABLED` | "Replacement Tracking & Approvals" (RT&A) is not enabled |

 */
export type RestaurantFulfillmentIssueCustomerAckType =
  (typeof RestaurantFulfillmentIssueCustomerAckType)[keyof typeof RestaurantFulfillmentIssueCustomerAckType]

export const RestaurantFulfillmentIssueCustomerAckType = {
  ACK_DISABLED: 'ACK_DISABLED',
} as const

export type RestaurantFulfillmentIssue = {
  issue_type?: RestaurantIssueType
  action_type?: RestaurantActionType
  root_item?: FulfillmentIssueItem
  item_availability?: ItemAvailability
  item_substitute?: ItemSubstitute
  suspend_until?: SuspendUntil
  store_response?: StoreResponse
  /** Specifies the customer acknowledgment type required for a replacement including the customer‚Äôs response. This field is only populated for ‚ÄúRetail‚Äù merchants only.
| String | Description |
| ------ | ----- |
| `ACK_DISABLED` | "Replacement Tracking & Approvals" (RT&A) is not enabled |
   */
  customer_ack_type?: RestaurantFulfillmentIssueCustomerAckType
}

/**
 * Specifies the customer acknowledgment type required for a replacement including the customer‚Äôs response. This field is only populated for ‚ÄúRetail‚Äù merchants only.
| String | Description |
| ------ | ----- |
| `ACK_DISABLED` | "Replacement Tracking & Approvals" (RT&A) is not enabled |
| `NO_ACK_REQUIRED` | Customer acknowledgment for replacements is not required. |
| `AWAITING_ACTION` | Awaiting customer acknowledgment of replacement. |
| `SUBSTITUTION_REJECTED` | The customer rejects the replacement suggestions provided by the merchant, the affected item is automatically removed from the order. The Merchant can suggest a new replacement.|
| `SUBSTITUTION_APPROVED` | The customer approves the replacement suggestions provided by the merchant. No further action is required from the merchant.|

 */
export type RetailFulfillmentIssueCustomerAckType =
  (typeof RetailFulfillmentIssueCustomerAckType)[keyof typeof RetailFulfillmentIssueCustomerAckType]

export const RetailFulfillmentIssueCustomerAckType = {
  ACK_DISABLED: 'ACK_DISABLED',
  NO_ACK_REQUIRED: 'NO_ACK_REQUIRED',
  AWAITING_ACTION: 'AWAITING_ACTION',
  SUBSTITUTION_REJECTED: 'SUBSTITUTION_REJECTED',
  SUBSTITUTION_APPROVED: 'SUBSTITUTION_APPROVED',
} as const

export type RetailFulfillmentIssue = {
  issue_type?: RetailIssueType
  action_type?: RetailActionType
  root_item?: FulfillmentIssueItem
  item_availability?: ItemAvailability
  item_substitute?: ItemSubstitute
  suspend_until?: SuspendUntil
  store_response?: StoreResponse
  /** Specifies the customer acknowledgment type required for a replacement including the customer‚Äôs response. This field is only populated for ‚ÄúRetail‚Äù merchants only.
| String | Description |
| ------ | ----- |
| `ACK_DISABLED` | "Replacement Tracking & Approvals" (RT&A) is not enabled |
| `NO_ACK_REQUIRED` | Customer acknowledgment for replacements is not required. |
| `AWAITING_ACTION` | Awaiting customer acknowledgment of replacement. |
| `SUBSTITUTION_REJECTED` | The customer rejects the replacement suggestions provided by the merchant, the affected item is automatically removed from the order. The Merchant can suggest a new replacement.|
| `SUBSTITUTION_APPROVED` | The customer approves the replacement suggestions provided by the merchant. No further action is required from the merchant.|
   */
  customer_ack_type?: RetailFulfillmentIssueCustomerAckType
}

export type RestaurantResolveFulfillmentIssues = {
  /** Issues affecting merchant‚Äôs ability to fulfill the order. */
  fulfillment_issues?: RestaurantResolveFulfillmentIssue[]
}

export type RestaurantResolveFulfillmentIssue = {
  issue_type?: RestaurantIssueType
  action_type?: RestaurantActionType
  item?: RootItem
  suspend_until?: SuspendUntil
  store_response?: StoreResponse
}

export type RetailResolveFulfillmentIssues = {
  /** Issues affecting merchant‚Äôs ability to fulfill the order. */
  fulfillment_issues?: RetailResolveFulfillmentIssue[]
}

export type RetailResolveFulfillmentIssue = {
  issue_type?: RetailIssueType
  action_type?: RetailActionType
  item?: RootItem
  item_availability?: ItemAvailability
  item_substitute?: ItemSubstitute
  suspend_until?: SuspendUntil
  store_response?: StoreResponse
}

export type RestaurantResponseFulfillmentIssues = {
  /** Whether or not the merchant should wait for the customer to resolve the fulfillment issue (or order cancellation due to timeout waiting for customer response). If true, waiting for either the `order.fulfillment_issues.resolved` webhook or the `order.failed webhook`. */
  should_wait_for_customer_response?: boolean
}

export type RetailResponseFulfillmentIssues = {
  /** Whether or not the merchant should wait for the customer to resolve the fulfillment issue. */
  should_wait_for_customer_response?: boolean
}

export type FulfillmentCartItemId = {
  /** Cart item ID of the affected item. Corresponds to the same field on order.carts items within the Get Order Details reponse. */
  cart_item_id?: string
}

export type RestrictedItems = {
  alcohol?: Alcohol
  tobacco?: Tabacco
}

export type Alcohol = {
  /** Flag that indicates whether there are any alcoholic items in the order. */
  contain_alcoholic_item?: boolean
}

export type Tabacco = {
  /** Flag that indicates whether there are any items that contain tobacco. */
  contain_tobacco_product?: boolean
}

/**
 * Provides info on the available items in the instance where `issue_type` is `PARTIAL_AVAILABILITY` or `FOUND_ITEM`.
 */
export type ItemAvailability = {
  items_available?: Piw
}

/**
 * Reason why an order failed.
 */
export type FailureInfoReason = (typeof FailureInfoReason)[keyof typeof FailureInfoReason]

export const FailureInfoReason = {
  POS_DENIED: 'POS_DENIED',
  ACCEPT_TIMED_OUT: 'ACCEPT_TIMED_OUT',
  DELIVERY_FAILED: 'DELIVERY_FAILED',
  CANCELED: 'CANCELED',
  UNKNOWN: 'UNKNOWN',
} as const

/**
 * The party who canceled the order. Only available if the attribution can be reasonably determined.
 */
export type FailureInfoFailureAttributedToParty =
  (typeof FailureInfoFailureAttributedToParty)[keyof typeof FailureInfoFailureAttributedToParty]

export const FailureInfoFailureAttributedToParty = {
  UNKNOWN: 'UNKNOWN',
  MERCHANT: 'MERCHANT',
  CUSTOMER: 'CUSTOMER',
  UBER: 'UBER',
  DELIVERY_PARTNER: 'DELIVERY_PARTNER',
} as const

/**
 * Information on why an order failed. Only available for orders with state of `FAILED`.
 */
export type FailureInfo = {
  /** Reason why an order failed. */
  reason?: FailureInfoReason
  /** The party who canceled the order. Only available if the attribution can be reasonably determined. */
  failure_attributed_to_party?: FailureInfoFailureAttributedToParty
  /** Whether or not the merchant will be paid for this order failure. Only available if reason is CANCELED. */
  will_merchant_be_paid?: boolean
  /** If provided, a descriptive reason selected by the party. For example, for delivery partner cancellations, it could be ‚Äòcould not find customer‚Äô */
  description?: string
}

/**
 * Source of the ready_for_pickup_time_secs value
 */
export type PreparationTimeSource = (typeof PreparationTimeSource)[keyof typeof PreparationTimeSource]

export const PreparationTimeSource = {
  PREDICTED_BY_UBER: 'PREDICTED_BY_UBER',
  DEFAULT: 'DEFAULT',
  MERCHANT_PROVIDED: 'MERCHANT_PROVIDED',
} as const

/**
 * Info related to preparation times of this order.
 */
export type PreparationTime = {
  /** Amount of time it takes from the point of order acceptance until an order is ready to be picked up. This is a duration value in seconds. */
  ready_for_pickup_time_secs?: number
  /** Source of the ready_for_pickup_time_secs value */
  source?: PreparationTimeSource
  /** Timestamp in RFC3339 format. The estimated time when the order would be ready for pickup. */
  ready_for_pickup_time?: string
}

/**
 * Actions that the Merchant can undertake on the order.
 */
export type ActionEligibility = {
  /** Whether or not the ready for pickup time can be adjusted. If this is false then clients should not pass in the corresponding field in the AcceptOrder endpoint nor should they call the UpdateOrderReadyForPickupTime endpoint. */
  adjust_ready_for_pickup_time?: ActionEligibilityDetails
  /** A flag that indicates whether the order is eligible for out-of-item actions using the Resolve Fulfillment Issues endpoint. */
  mark_out_of_item?: ActionEligibilityDetails
  /** Indicates whether an order can be canceled. */
  cancel?: ActionEligibilityDetails
  /** Indicates whether an Order can make use of the regular cannot fulfill instructions flow. */
  mark_cannot_fulfill?: ActionEligibilityDetails
  /** Indicates whether an estimated time of delivery can be updated for an order. */
  adjust_etd_time?: ActionEligibilityDetails
  /** Indicates whether the customer can request for an estimated time of delivery update. */
  customer_request_etd?: ActionEligibilityDetails
}

export type ActionEligibilityDetails = {
  /** Flag indicating whether the action is eligible. */
  is_eligible?: boolean
  /** Description giving context on why the action is eligible or not. */
  reason?: string
}

/**
 * Details of the order.
 */
export type RestaurantOrderOrder = {
  id?: OrderId
  display_id?: OrderDisplayId
  external_id?: OrderExternalId
  state?: OrderState
  status?: OrderStatus
  preparation_status?: OrderPreparationStatus
  ordering_platform?: OrderOrderingPlatform
  fulfillment_type?: OrderFulfillmentType
  scheduled_order_target_delivery_time_range?: TimeRange
  store?: Store
  customers?: OrderCustomer
  deliveries?: OrderDelivery
  /** List of shopping carts associated with the order. */
  carts?: RestaurantShoppingCart[]
  payment?: Payment
  is_order_accuracy_risk?: IsOrderAccuracyRisk
  store_instructions?: OrderStoreInstructions
  preparation_time?: PreparationTime
  completed_time?: OrderCompletedTime
  eligible_actions?: ActionEligibility
  failure_info?: FailureInfo
  created_time?: OrderCreatedTime
  has_membership_pass?: OrderHasMembershipPass
  retailer_loyalty_info?: RetailerLoyaltyInfo
  order_tracking_metadata?: OrderTrackingMetadata
}

export type RestaurantOrder = {
  /** Details of the order. */
  order?: RestaurantOrderOrder
}

/**
 * Details of the order.
 */
export type RetailOrderOrder = {
  id?: OrderId
  display_id?: OrderDisplayId
  external_id?: OrderExternalId
  state?: OrderState
  status?: OrderStatus
  preparation_status?: OrderPreparationStatus
  ordering_platform?: OrderOrderingPlatform
  fulfillment_type?: OrderFulfillmentType
  scheduled_order_target_delivery_time_range?: TimeRange
  store?: Store
  customers?: OrderCustomer
  deliveries?: OrderDelivery
  /** List of shopping carts associated with the order. */
  carts?: RetailShoppingCart[]
  payment?: Payment
  is_order_accuracy_risk?: IsOrderAccuracyRisk
  store_instructions?: OrderStoreInstructions
  preparation_time?: PreparationTime
  completed_time?: OrderCompletedTime
  eligible_actions?: ActionEligibility
  failure_info?: FailureInfo
  created_time?: OrderCreatedTime
  has_membership_pass?: OrderHasMembershipPass
  retailer_loyalty_info?: RetailerLoyaltyInfo
  order_tracking_metadata?: OrderTrackingMetadata
}

export type RetailOrder = {
  /** Details of the order. */
  order?: RetailOrderOrder
}

/**
 * | String              | Description |
| -------- | ----------- |
| `DELIVERY_BY_UBER`    | Delivered by Uber. |
| `DELIVERY_BY_MERCHANT` | Delivered by partner's couriers Bring Your Own Courier (BYOC). |
| `DINE_IN`             | Dining in. |
| `PICKUP`              | Customer picking up the order. |

 */
export type OrderFulfillmentType = (typeof OrderFulfillmentType)[keyof typeof OrderFulfillmentType]

export const OrderFulfillmentType = {
  DELIVERY_BY_UBER: 'DELIVERY_BY_UBER',
  DELIVERY_BY_MERCHANT: 'DELIVERY_BY_MERCHANT',
  DINE_IN: 'DINE_IN',
  PICKUP: 'PICKUP',
} as const

/**
 * The Uber property under which the order was placed.
 */
export type OrderOrderingPlatform = (typeof OrderOrderingPlatform)[keyof typeof OrderOrderingPlatform]

export const OrderOrderingPlatform = {
  UBER_EATS: 'UBER_EATS',
  POSTMATES: 'POSTMATES',
} as const

/**
 * | String    | Description |
| --------- | ----------- |
| `SCHEDULED` | Order is scheduled for a future time. |
| `ACTIVE`    | Order is active. |
| `COMPLETED` | Order is completed. |

 */
export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]

export const OrderStatus = {
  SCHEDULED: 'SCHEDULED',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  UNKNOWN: 'UNKNOWN',
} as const

/**
 * | String     | Description |
| ---------- | -------------- |
| `PREPARING`                        | Order is being prepared. |
| `OUT_OF_ITEM_PENDING_CUSTOMER_RESPONSE` | Merchant has indicated out of item and the order is now waiting on customer response. |
| `READY_FOR_HANDOFF`                | Order is ready to be handed off. |

 */
export type OrderPreparationStatus = (typeof OrderPreparationStatus)[keyof typeof OrderPreparationStatus]

export const OrderPreparationStatus = {
  PREPARING: 'PREPARING',
  OUT_OF_ITEM_PENDING_CUSTOMER_RESPONSE: 'OUT_OF_ITEM_PENDING_CUSTOMER_RESPONSE',
  READY_FOR_HANDOFF: 'READY_FOR_HANDOFF',
} as const

/**
 * | String | Description |
| ------ | ----- |
| `OFFERED` | Order has been offered to the merchant. |
| `ACCEPTED` | Merchant has accepted the order. |
| `HANDED_OFF` | Order has been fully handed off to delivery partners. If there are multiple delivery partners, an order will only transition to this state only when all delivery partners have picked up the order. |
| `SUCCEEDED` | Order was successfully delivered. |
| `FAILED` | Order failed for any reason. |
| `UNKNOWN` | Catch all for unrecognized states. |

 */
export type OrderState = (typeof OrderState)[keyof typeof OrderState]

export const OrderState = {
  CREATED: 'CREATED',
  OFFERED: 'OFFERED',
  ACCEPTED: 'ACCEPTED',
  HANDED_OFF: 'HANDED_OFF',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  UNKNOWN: 'UNKNOWN',
} as const

/**
 * An external unique identifier for the order provided by the Merchant. This can be set by the application within the Accept Order request.
 */
export type OrderExternalId = string

/**
 * An identifier for the order that is displayed on the receipt or other Merchant surfaces.
 */
export type OrderDisplayId = string

/**
 * A unique identifier for a given order. This is the identifier that is expected to be quoted for support queries and is otherwise known as the ‚Äòorder id‚Äô.
 */
export type OrderId = string

/**
 * Marks an order that has the highest potential to be inaccurate (i.e. missing items).
 */
export type IsOrderAccuracyRisk = boolean

/**
 * Customer specified instructions for the Merchant on the order.
 */
export type OrderStoreInstructions = string

/**
 * Timestamp in RFC3339 format. Timestamp of when the order is no longer active (i.e. successfully delivered, failed etc.). Only available for a completed order.
 */
export type OrderCompletedTime = string

/**
 * Timestamp in RFC3339 format. Creation time of the order.
 */
export type OrderCreatedTime = string

/**
 * Indicates whether an order is benefiting from Eats Pass membership.
 */
export type OrderHasMembershipPass = boolean

/**
 * The type of category of cancellation:

| Name                       | Description                       |
| -------------------------- | --------------------------------- |
| `ITEM_ISSUE`               | Issue with an item or modifier    |
| `KITCHEN_CLOSED`           | Kitchen is closed                 |
| `CUSTOMER_CALLED_TO_CANCEL`| Customer called to cancel         |
| `RESTAURANT_TOO_BUSY`      | Restaurant is too busy            |
| `ORDER_VALIDATION`         | Order validation error            |
| `STORE_CLOSED`             | Store is closed                   |
| `TECHNICAL_FAILURE`        | Technical failure                 |
| `POS_NOT_READY`            | POS not ready                     |
| `POS_OFFLINE`              | POS is offline                    |
| `CAPACITY`                 | Store order capacity is full      |
| `ADDRESS`                  | Problem with address              |
| `SPECIAL_INSTRUCTIONS`     | Special instructions issue        |
| `PRICING`                  | Pricing issues                    |
| `UNKNOWN`                  | Unknown reason                    |
| `OTHER`                    | Other                             |

 */
export type DenyReasonType = (typeof DenyReasonType)[keyof typeof DenyReasonType]

export const DenyReasonType = {
  ITEM_ISSUE: 'ITEM_ISSUE',
  KITCHENCLOSED: 'KITCHENCLOSED',
  CUSTOMER_CALLED_TO_CANCEL: 'CUSTOMER_CALLED_TO_CANCEL',
  RESTAURANT_TOO_BUSY: 'RESTAURANT_TOO_BUSY',
  ORDER_VALIDATION: 'ORDER_VALIDATION',
  STORE_CLOSED: 'STORE_CLOSED',
  TECHNICAL_FAILURE: 'TECHNICAL_FAILURE',
  POS_NOT_READY: 'POS_NOT_READY',
  POS_OFFLINE: 'POS_OFFLINE',
  CAPACITY: 'CAPACITY',
  ADDRESS: 'ADDRESS',
  SPECIAL_INSTRUCTIONS: 'SPECIAL_INSTRUCTIONS',
  PRICING: 'PRICING',
  UNKNOWN: 'UNKNOWN',
  OTHER: 'OTHER',
} as const

export type DenyReason = {
  /** A free text string that holds additional information for the denial/cancellation. */
  info?: string
  /** The type of category of cancellation:

| Name                       | Description                       |
| -------------------------- | --------------------------------- |
| `ITEM_ISSUE`               | Issue with an item or modifier    |
| `KITCHEN_CLOSED`           | Kitchen is closed                 |
| `CUSTOMER_CALLED_TO_CANCEL`| Customer called to cancel         |
| `RESTAURANT_TOO_BUSY`      | Restaurant is too busy            |
| `ORDER_VALIDATION`         | Order validation error            |
| `STORE_CLOSED`             | Store is closed                   |
| `TECHNICAL_FAILURE`        | Technical failure                 |
| `POS_NOT_READY`            | POS not ready                     |
| `POS_OFFLINE`              | POS is offline                    |
| `CAPACITY`                 | Store order capacity is full      |
| `ADDRESS`                  | Problem with address              |
| `SPECIAL_INSTRUCTIONS`     | Special instructions issue        |
| `PRICING`                  | Pricing issues                    |
| `UNKNOWN`                  | Unknown reason                    |
| `OTHER`                    | Other                             |
   */
  type?: DenyReasonType
  /** A partner provided error code. */
  client_error_code?: string
  item_metadata?: ItemMetadata
}

/**
 * An object that houses metadata related to items that resulted in the deny request.
 */
export type ItemMetadata = {
  /** A list of items with issues that resulted in the deny call. */
  invalid_item?: InvalidItem
}

/**
 * An object that encapsulates specific item data related to a deny call
 */
export type InvalidItem = InvalidItems[]

/**
 * The specific type of item issue.
 */
export type InvalidItemsType = (typeof InvalidItemsType)[keyof typeof InvalidItemsType]

export const InvalidItemsType = {
  NOT_ON_MENU: 'NOT_ON_MENU',
  UNAVAILABLE: 'UNAVAILABLE',
  MISSING_INFO: 'MISSING_INFO',
  PRICING: 'PRICING',
  QUANTITY: 'QUANTITY',
  OUT_OF_ITEM: 'OUT_OF_ITEM',
  OTHER: 'OTHER',
} as const

export type InvalidItems = {
  /** The id of the impacted item. This is expected to be the Uber UUID of the impacted item or modifier (option). */
  id?: string
  /** The specific type of item issue. */
  type?: InvalidItemsType
  /** The client error code associated with the item issue. */
  client_error_code?: string
  /** A free text field that can be used to provide additional context to the item issue. */
  info?: string
  /** The id of the impacted item as identified by the client system. Whereas item_id is expected to be the Uber UUID of the item, this field is intended to be the identifier of the item as per the client system. */
  external_id?: string
}

/**
 * The reason for canceling the order
 */
export type CancellationReason = DenyReason

export type EmptyBody = {
  [key: string]: unknown
}

/**
 * | String |    Description |
| ----- | ------------|
| `REQUESTED_ADD_ONS` | Customer requested an add on. |
| `BIGGER_SIZE` | Customer requested bigger size item. |
| `NEW_ITEM_ADDED` | A new item is added to the order. |
| `ITEM_SOLD_OUT` | A item is sold out. |
| `REMOVED_ITEM` | An item is removed from the order. |
| `ADD_ON_UNAVAILABLE` | A requested add on is unavailable. |
| `OTHER` | Other reasons. Note that the custom_reason field below must be populated if this is specified. |

 */
export type AdjustPriceReason = (typeof AdjustPriceReason)[keyof typeof AdjustPriceReason]

export const AdjustPriceReason = {
  REQUESTED_ADD_ONS: 'REQUESTED_ADD_ONS',
  BIGGER_SIZE: 'BIGGER_SIZE',
  NEW_ITEM_ADDED: 'NEW_ITEM_ADDED',
  ITEM_SOLD_OUT: 'ITEM_SOLD_OUT',
  REMOVED_ITEM: 'REMOVED_ITEM',
  ADD_ON_UNAVAILABLE: 'ADD_ON_UNAVAILABLE',
  OTHER: 'OTHER',
} as const

/**
 * The adjustment of order price
 */
export type AdjustPrice = {
  /** Amount expressed as a whole number with multiplier as 10^-5, e.g. 1.2345 will be represented as 12345 Price can be adjusted upwards or downwards. Note that there is a maximum price that can be adjusted. If not configured, it is defaulted to 5000000 ($50 in local currency). A bad request error will be returned for an amount violating this constraint. To adjust price downwards, use a negative value. The resulting price cannot be less than 0. Otherwise a bad request error will be returned. */
  amount_e5?: number
  /** Tax rate to adjust the order with, in percentage. For example, specify ‚Äú8.75‚Äù for a 8.75% tax rate. In tax inclusive regions (where tax is included in the item price), this value must be provided. In tax exclusive regions, this value can only be provided if the merchant is not using the Vertex tax engine. Tax rate provided in the request will be a no-op. The response will return an indication if the tax rate provided is actually being applied. Excessively high tax rate (e.g. 100%) will result in a bad request error. */
  tax_rate?: string
  /** | String |    Description |
| ----- | ------------|
| `REQUESTED_ADD_ONS` | Customer requested an add on. |
| `BIGGER_SIZE` | Customer requested bigger size item. |
| `NEW_ITEM_ADDED` | A new item is added to the order. |
| `ITEM_SOLD_OUT` | A item is sold out. |
| `REMOVED_ITEM` | An item is removed from the order. |
| `ADD_ON_UNAVAILABLE` | A requested add on is unavailable. |
| `OTHER` | Other reasons. Note that the custom_reason field below must be populated if this is specified. |
   */
  reason?: AdjustPriceReason
  /** Free-form string. Must be provided if OTHER is specified as reason. */
  custom_reason?: string
}

/**
 * Payment details on the order.
 */
export type Payment = {
  /** The payment details on the order. */
  payment_detail?: PaymentDetail
  /** Detailed information about the tax charges calculated on the Order. */
  tax_reporting?: TaxReporting
}

/**
 * Detailed information about the tax charges calculated on the Order.
 */
export type TaxReporting = {
  /** A breakdown of taxes in the order. */
  breakdown?: Breakdown
  /** The tax location information for the orders origin. */
  origin?: TaxLocation
  /** The tax location for the orders destination. */
  destination?: TaxLocation
  /** A breakdown of the remittance information for a given tax type. */
  remittance_info?: RemittanceInfo[]
}

/**
 * The entity that is responsible for remittance.
 */
export type RemittanceInfoEntity = (typeof RemittanceInfoEntity)[keyof typeof RemittanceInfoEntity]

export const RemittanceInfoEntity = {
  UBER: 'UBER',
  MERCHANT: 'MERCHANT',
  DELIVERY_PARTNER: 'DELIVERY_PARTNER',
  CUSTOMER: 'CUSTOMER',
} as const

/**
 * The specific type of tax to be remitted.
 */
export type RemittanceInfoType = (typeof RemittanceInfoType)[keyof typeof RemittanceInfoType]

export const RemittanceInfoType = {
  SUBTOTAL: 'SUBTOTAL',
  DELIVERY_FEE: 'DELIVERY_FEE',
} as const

/**
 * Remittance details of the taxes in the order and the responsible entity.
 */
export type RemittanceInfo = {
  /** The entity that is responsible for remittance. */
  entity?: RemittanceInfoEntity
  /** The specific type of tax to be remitted. */
  type?: RemittanceInfoType
  /** The amount that the entity is responsible for remitting. */
  amount?: CurrencyAmount
}

/**
 * The breakdown of tax charges on the order.
 */
export type Breakdown = {
  /** A list of tax items, where each entry provides details of the taxes calculated for a given shopping cart item. */
  items?: TaxItem[]
  /** A list of tax items, where each entry provides details of the taxes calculated on fees that are associated with a given shopping cart item. */
  fees?: TaxItem[]
  /** A list of tax items, where each entry provides details of the taxes calculated on promotions that are associated with a given shopping cart item. */
  promotions?: TaxItem[]
}

/**
 * The type of tax that this info is associated with.
 */
export type TaxItemDescription = (typeof TaxItemDescription)[keyof typeof TaxItemDescription]

export const TaxItemDescription = {
  DELIVERY_FEE: 'DELIVERY_FEE',
  SERVICE_FEE: 'SERVICE_FEE',
  SMALL_ORDER_FEE: 'SMALL_ORDER_FEE',
  Etc: 'Etc.',
} as const

/**
 * The tax information related to a single shopping cart item (instance_id) or tax type.
 */
export type TaxItem = {
  /** The shopping cart item that the tax info is associated with. If empty, it means that the given tax item is not associated with a specific cart item. */
  instance_id?: string
  /** The type of tax that this info is associated with. */
  description?: TaxItemDescription
  /** The total amount of the charge including taxes for this item. */
  gross_amount?: CurrencyAmount
  /** The total amount of the charge less any taxes applicable to the item. */
  net_amount?: CurrencyAmount
}

/**
 * Tax location information for a given entity
 */
export type TaxLocation = {
  /** The location id as provided by Uber Tax. */
  id?: string
  /** The ISO2 country code for the given tax location. */
  country_iso2?: string
  /** The postal or zip code. */
  postal_code?: string
}

/**
 * A breakdown of payment information on the order.
 */
export type PaymentDetail = {
  /** The total of all the items, fees, taxes, promotions on the order. */
  order_total?: Money
  /** The total of all the shopping cart items including any taxes on the order. */
  item_charges?: ItemChargeSummary
  /** The total of all the fees on the order, including any taxes on the order. */
  fees?: MerchantFeeSummary
  /** The total tips including any taxes on it for the order. */
  tips?: MerchantTipSummary
  /** The total of all promotions on the order, including any taxes. */
  promotions?: PromotionSummary
  /** Price adjustments merchants applied to this order. */
  adjustment?: PriceAdjustmentSummary
  /** The currency in which the order has taken place. */
  currency_code?: string
  /** The amount of cash to be collected from a Customer. */
  cash_amount_due?: Money
}

/**
 * The money representation of a charge.
 */
export type Money = {
  /** Display amount for the charge. It is designed to factor in whether the charge is inclusive or exclusive of tax. */
  display_amount?: string
  /** The amount of the charge, not inclusive of taxes. */
  net?: CurrencyAmount
  /** The tax on the charge. */
  tax?: CurrencyAmount
  /** The total of the charge, inclusive of taxes. */
  gross?: CurrencyAmount
  /** Is the charge inclusive or exclusive of tax. */
  is_tax_inclusive?: boolean
}

/**
 * An object that represents item charges
 */
export type ItemChargeSummary = {
  /** Subtotal (cost of all items) without promotions applied. */
  total?: Money
  /** Subtotal inclusive of the discounts on the item. */
  subtotal_including_promos?: Money
  /** Pricing data for each item in the order */
  price_breakdown?: ItemPrice[]
}

/**
 * An object that contains information related to the price of a single item.
 */
export type ItemPrice = {
  cart_item_id?: CartItemId
  /** The entity type of which this price applies to. */
  price_type?: string
  /** Quantity of the item in the cart */
  quantity?: QuantityPIW
  /** Total price of the item based on the quantity selected and charge thresholds before discounts are applied. */
  total?: Total
  /** Discount-related information, if applicable */
  discount?: ItemDiscount
  /** Price of a single unit of the item. In cases where `quantity.amount` is 1, this should be equivalent to `total` */
  unit?: Money
  /** Price of a single unit of the item before any loyalty discounts are applied. */
  base_non_loyalty_unit?: Money
}

/**
 * Object that contains discount related to the items.
 */
export type ItemDiscount = {
  /** the money representation of the item charge. */
  total?: Money
  /** Quantity of items discount applies */
  quantity?: Quantity
}

/**
 * Total for money values
 */
export type Total = {
  /** How we expect the amount to be displayed. It is designed to factor in whether the charge is inclusive or exclusive of tax. It provides a convenient way for consumers to display the line item amount. */
  display_amount?: string
  /** the amount of the change, not inclusive of tax. */
  net?: CurrencyAmount
  /** the tax on the charge. */
  tax?: CurrencyAmount
  /** the total of the charge, inclusive of tax. */
  gross?: CurrencyAmount
  /** Is the charge inclusive or exclusive of tax. */
  is_tax_inclusive?: boolean
}

/**
 * A breakdown of the fees applicable to a given order.
 */
export type MerchantFeeSummary = {
  /** The total of the fees on the order */
  total?: Money
  /** A breakdown of the fees that contribute to the total. */
  details?: MerchantFee[]
}

/**
 * The identifier for a given fee.
 */
export type MerchantFeeId = (typeof MerchantFeeId)[keyof typeof MerchantFeeId]

export const MerchantFeeId = {
  SMALL_ORDER_FEE: 'SMALL_ORDER_FEE',
  DELIVERY_FEE: 'DELIVERY_FEE',
  PICK_AND_PACK_FEE: 'PICK_AND_PACK_FEE',
  BAG_FEE: 'BAG_FEE',
} as const

/**
 * A description of a single Merchant Fee on an order.
 */
export type MerchantFee = {
  /** The identifier for a given fee. */
  id?: MerchantFeeId
  /** The amount charged on a given fee (id) */
  amount?: Money
}

/**
 * A summary of Merchant Tips
 */
export type MerchantTipSummary = {
  /** The total amount of the Merchant tip on the order. */
  total?: Money
}

/**
 * An object that represents details on the promotions in the order.
 */
export type PromotionSummary = {
  /** The total amount of the promotion on the order. */
  total?: Money
  /** A breakdown of the promotions applied on the order. */
  details?: PromotionDetail[]
  /** The order total without any promotions applied. */
  order_total_excluding_promos?: Money
}

export type PromotionDetailPromoFundingSplitsItem = {
  /** The source of the funding for the promotion. */
  funding_source?: string
  /** The amount allocated from this funding source. */
  amount_paid?: Money
}

/**
 * The details about an individual promotion.
 */
export type PromotionDetail = {
  /** An identifier that represents a single promotion that has been provided by a Partner. */
  external_promotion_id?: string
  /** The type of promotion (i.e. BOGO, GETXGETY, FREE_ITEM, DISCOUNTED_ITEM, BOGA, CATEGORY_DISCOUNT, FLAT, PERCENT, etc) */
  type?: string
  /** The promotion amount. */
  discount_value?: string
  /** The percentage of the discount. */
  discount_percentage?: string
  /** This indicates the delivery fee value applied from the promotion */
  discount_delivery_fee_value?: string
  discount_items?: DiscountItems
  /** This is the unique promotion uuid associated with promotion. */
  promotion_uuid?: string
  /** This is an array of objects, each element displaying the funding provider for this promotion and giving the exact amount paid by that funding provider. */
  promo_funding_splits?: PromotionDetailPromoFundingSplitsItem[]
}

/**
 * An object that represents the details on the price adjustment.
 */
export type PriceAdjustmentSummary = {
  /** The total of the price adjustment. */
  total?: Money
  /** A detailed breakdown of the adjustments on the order. */
  details?: AdjustmentDetails
}

/**
 * An object that provides details of the adjustments on the order.
 */
export type AdjustmentDetails = {
  /** The amount of the adjustment */
  amount?: Money
  /** The reason for the adjustment */
  reason?: string
}

/**
 * The details about the amount and its currency
 */
export type CurrencyAmount = {
  /** The amount expressed as a whole number with multiplier 10^5, e.g. 1.2345 will be represented as 12345 */
  amount_e5?: number
  /** 3-letter alphanumeric code indicating the currency, e.g. USD */
  currency_code?: string
  /** Localized amount, e.g. $1.23 */
  formatted?: string
}

/**
 * Retailer loyalty identifier.
 */
export type RetailerLoyaltyInfo = {
  /** Retailer loyalty number */
  loyalty_number?: string
}

/**
 * Field to store order tracking metadata for BYOC orders. This is only populated when a merchant is set to handle Bring-Your-Own-Courier ("BYOC") orders. For all other fulfillment types, like "DELIVERY_BY_UBER", this object is omitted.
 */
export type OrderTrackingMetadata = {
  /** BYOC Order Tracking HTTP URL that represents the QR code content. */
  url?: string
}

export type DiscountItemsItem = {
  /** This is the partner's external ID for the applied promotion. */
  external_id?: string
  /** This is the quantity of the item with a promotion applied. */
  discounted_quantity?: number
  /** This is the total saving amount for the certain items with a promo applied. Example ‚Äú-5000‚Äù means the order saves 50 in local currency for the target item. */
  discount_amount_applied?: number
}

export type DiscountItems = DiscountItemsItem[]

/**
 * Pagination information
 */
export type PaginationData = {
  /** Token to retrieve the next page. This is only returned if there is a next page. */
  next_page_token?: string
  /** Number of orders in the response for this page */
  page_size?: number
}

export type Feedback = {
  /** Unique identifier of the store. */
  store_id?: string
  /** Unique identifier of the delivery. */
  delivery_id?: string
  /** Rating for the delivery partner
| String    | Description |
| ---- | ---- |
| `THUMBS_UP` | delivery partner performed well |
| `THUMBS_DOWN` | there was an issue with the delivery partner‚Äôs performance |
   */
  rating?: string
  /** Description of why the delivery partner is being given a rating. */
  reason?: string
}

/**
 * Error message not standardized. Application code will provide contextual error message
 */
export type ErrorMetadataProperty = { [key: string]: unknown }

/**
 * bad_request
 */
export type Error = {
  /** Error message not standardized. Application code will provide contextual error message */
  metadata?: ErrorMetadataProperty
}

/**
 * Additional metadata about the error.
 */
export type BadRequestErrorMetadata = {
  /** A list of invalid or missing fields passed in the request. */
  field_violations?: string[]
  /** Only provided for API Version 2.0.0 and higher. Indicates if the request should be retried. */
  should_retry?: boolean
  /** Only provided for API Version 2.0.0 and higher. The recommended wait interval in seconds between retries. Only provided if should_retry is true. */
  recommended_retry_interval_secs?: number
  /** Only provided for API Version 2.0.0 and higher. Link to reference documentation about the error. */
  reference_documentation_url?: string
  /** Only provided for API Version 2.0.0 and higher. Indicates which field passed in could be changed to fix the error. */
  erroneous_field?: string
}

/**
 * bad_request
 */
export type BadRequestError = {
  /** Description of the error. */
  code?: string
  /** Description details of the error. */
  message?: string
  /** Additional metadata about the error. */
  metadata?: BadRequestErrorMetadata
}

/**
 * unauthorized
 */
export type UnauthorizedError = {
  /** Description of the error. */
  code?: string
  /** Description details of the error. */
  message?: string
  /** Additional metadata about the error. */
  metadata?: ErrorMetadata
}

/**
 * not_found
 */
export type NotFoundError = {
  /** Description of the error. */
  code?: string
  /** Description details of the error. */
  message?: string
  /** Additional metadata about the error. */
  metadata?: ErrorMetadata
}

/**
 * internal_server_error
 */
export type InternalServerError = {
  /** Description of the error. */
  code?: string
  /** Description details of the error. */
  message?: string
  /** Additional metadata about the error. */
  metadata?: ErrorMetadata
}

/**
 * Only provided for API Version 2.0.0 and higher. Additional metadata about an error.
 */
export type ErrorMetadata = {
  /** Indicates if the request should be retried. */
  should_retry?: boolean
  /** The recommended wait interval in seconds between retries. */
  recommended_retry_interval_secs?: number
  /** Link to reference documentation about the error. */
  reference_documentation_url?: string
  /** Indicates which field passed in could be changed to fix the error. */
  erroneous_field?: string
}

/**
 * payload reverted for unsucessful API transactions.
 */
export type ErrorResponse = {
  /** description of the error. */
  code?: string
  /** description details of the error. */
  message?: string
}

export type GetOrderParams = {
  /**
   * Comma-separated list of fields to expand. Expected values 'carts','deliveries' and/or 'payment'. By default, these fields in the MerchantOrder are omitted from the response unless specified. For example ‚Äòcarts,payment‚Äô returns an order with the ‚Äòcarts‚Äô and ‚Äòpayment‚Äô fields included.
   */
  expand?: string
}

export type GetOrder200 = RestaurantOrder | RetailOrder

export type GetOrdersParams = {
  /**
   * Comma-separated list of fields to expand. Expected values 'carts','deliveries' and/or 'payment'. By default, these fields in the MerchantOrder are omitted from the response unless specified. For example ‚Äòcarts,payment‚Äô returns an order with the ‚Äòcarts‚Äô and ‚Äòpayment‚Äô field included.
   */
  expand?: string
  /**
   * Comma-separated list of states. If omitted, orders in all states are returned. For example, ‚ÄòOFFERED,ACCEPTED‚Äô filters orders down to orders with these 2 states. Expected values:
| Name                       | Description                            |
| -------------------------- | ---------------------------------------|
| `OFFERED`                  | Order has been offered to the merchant |
| `ACCEPTED`                 | Merchant has accepted the order        |
| `HANDED_OFF`               | Order has been fully handed off to delivery partners. If there are multiple delivery partners, an order will only transition to this state only when all delivery partners have picked up the order. |
| `SUCCEEDED`                | Order was successfully delivered       |
| `FAILED`                   | Order failed for any reason            |
| `UNKNOWN`                  | Catch-all for unrecognized states      |

   */
  state?: string
  /**
   * Comma-separated list of statuses. If omitted, orders in all statuses are returned. For example, ‚ÄòSCHEDULED,ACTIVE‚Äô filters orders down to orders with these 2 statuses. Expected values:
| Name                       | Description                            |
| -------------------------- | ---------------------------------------|
| `SCHEDULED`                | Order is scheduled for a future time   |
| `ACTIVE`                   | Order is active                        |
| `COMPLETED`                | Order is completed                     |
| `UNKNOWN`                  | Catch-all for unrecognized statuses    |

   */
  status?: string
  /**
   * Timestamp in RFC3339 format. Filters down to orders created after this time. Must be before end_time if specified. If both start_time and end_time are not specified, all orders will be returned. Note that only orders within 60 days are returned.
   */
  start_time?: string
  /**
   * Timestamp in RFC3339 format. Filters down to orders created before this time. Must be after start_time if specified. If start_time is not specified, it is defaulted to 60 days ago.
   */
  end_time?: string
  /**
   * Pagination information - token to retrieve the next page. This token is provided in the pagination_data field if the response is paginated
   */
  next_page_token?: string
  /**
   * Pagination information - Number of orders in a single page. Only a maximum of 50 can be specified. If omitted, defaults to 50.
   */
  page_size?: number
}

export type GetOrders200 = {
  data?: RestaurantOrder[]
  pagination_data?: PaginationData
}

export type AcceptOrderBody = {
  /** An absolute RFC3339 timestamp, if passed, will inform how long the Order will take to prepare and have it ready to be picked up by a courier. */
  ready_for_pickup_time?: string
  /** It is the reference id from the external integrator for this specific Order if they have one and choose to send it. */
  external_reference_id?: string
  /** A free text field to indicate who the order was accepted by (i.e. Jane Smith, John Citizen). */
  accepted_by?: string
}

export type DenyOrderBody = {
  deny_reason?: DenyReason
}

export type CancelOrderBody = {
  cancellation_reason?: DenyReason
}

export type AdjustOrderPrice200 = {
  /** Whether or not the specified tax rate in the request is actually applied. This is false for stores in tax exclusive region that uses the Vertex tax engine. */
  tax_rate_applied?: boolean
}

export type UpdateOrderReadyTimeBody = {
  /** Timestamp in RFC3339 format that an Order will be ready to be picked up by a Delivery Partner. This will error out if incorrectly formatted or if a past time is sent. */
  ready_for_pickup_time?: string
}

export type ResolveOrderFulfillmentIssueBody = RestaurantResolveFulfillmentIssues | RetailResolveFulfillmentIssues

export type ResolveOrderFulfillmentIssue200 = RestaurantResponseFulfillmentIssues | RetailResponseFulfillmentIssues

/**
 * Provides detailed information regarding an Uber Eats active order that can be expanded to provide additional order information.
 * @summary Order Details
 */
export const getOrder = <TData = AxiosResponse<GetOrder200>>(
  orderId: string,
  params?: GetOrderParams,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/v1/delivery/order/${orderId}`, {
    ...options,
    params: { ...params, ...options?.params },
  })
}

/**
 * A list with detailed information regarding Uber Eats orders for a chosen restaurant
 * @summary List Orders Details
 */
export const getOrders = <TData = AxiosResponse<GetOrders200>>(
  storeId: string,
  params?: GetOrdersParams,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.get(`/v1/delivery/store/${storeId}/orders`, {
    ...options,
    params: { ...params, ...options?.params },
  })
}

/**
 * Allows Acceptance of an Uber Eats Order for timing of pickup to be updated for the customer or courier.
 * @summary Accept Order
 */
export const acceptOrder = <TData = AxiosResponse<void>>(
  orderId: string,
  acceptOrderBody: AcceptOrderBody,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/v1/delivery/order/${orderId}/accept`, acceptOrderBody, options)
}

/**
 * Allows an Uber Eats Order to be denied. You must supply a denial reason and can optionally supply a free form text to provide Uber further context as to why the order was unable to be accepted.
 * @summary Deny Order
 */
export const denyOrder = <TData = AxiosResponse<void>>(
  orderId: string,
  denyOrderBody: DenyOrderBody,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/v1/delivery/order/${orderId}/deny`, denyOrderBody, options)
}

/**
 * Allows cancellation of an Uber Eats Order
 * @summary Cancel Order
 */
export const cancelOrder = <TData = AxiosResponse<void>>(
  orderId: string,
  cancelOrderBody: CancelOrderBody,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/v1/delivery/order/${orderId}/cancel`, cancelOrderBody, options)
}

/**
 * Mark an order as ready for pickup. Merchants can call this endpoint when done preparing an order.
 * @summary Order Ready
 */
export const orderReady = <TData = AxiosResponse<void>>(
  orderId: string,
  emptyBody: EmptyBody,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/v1/delivery/order/${orderId}/ready`, emptyBody, options)
}

/**
 * Adjusts the price of an order of an active order for an Eater and awaits confirmation from the customer.
 * @summary Adjust Order Price
 */
export const adjustOrderPrice = <TData = AxiosResponse<AdjustOrderPrice200>>(
  orderId: string,
  adjustPrice: AdjustPrice,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/v1/delivery/order/${orderId}/adjust-price`, adjustPrice, options)
}

/**
 * Allows updating the time that an Eats Order will be ready to be picked up by a delivery partner. This can only be called when the Order is in the Accepted State and has not been marked as READY_TO_HANDOFF in the preparation_status. This endpoint will error out if can_adjust_ready_for_pickup_time is false.
 * @summary Update Order Ready Time
 */
export const updateOrderReadyTime = <TData = AxiosResponse<void>>(
  orderId: string,
  updateOrderReadyTimeBody: UpdateOrderReadyTimeBody,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(`/v1/delivery/order/${orderId}/update-ready-time`, updateOrderReadyTimeBody, options)
}

/**
 * Allows merchants to resolve fulfillment issues (e.g. out of item, cannot fulfill special instructions etc.) for a Uber Delivery Order. If successful, a customer can select to accept or adjust the cart for item, or cancel. Execution of this endpoint will be followed with order.fulfillment_issues.resolved or order.failed webhook.
 * @summary Resolve Fulfillment Issues
 */
export const resolveOrderFulfillmentIssue = <TData = AxiosResponse<ResolveOrderFulfillmentIssue200>>(
  orderId: string,
  resolveOrderFulfillmentIssueBody: ResolveOrderFulfillmentIssueBody,
  options?: AxiosRequestConfig
): Promise<TData> => {
  return axios.post(
    `/v1/delivery/order/${orderId}/resolve-fulfillment-issues`,
    resolveOrderFulfillmentIssueBody,
    options
  )
}

export type GetOrderResult = AxiosResponse<GetOrder200>
export type GetOrdersResult = AxiosResponse<GetOrders200>
export type AcceptOrderResult = AxiosResponse<void>
export type DenyOrderResult = AxiosResponse<void>
export type CancelOrderResult = AxiosResponse<void>
export type OrderReadyResult = AxiosResponse<void>
export type AdjustOrderPriceResult = AxiosResponse<AdjustOrderPrice200>
export type UpdateOrderReadyTimeResult = AxiosResponse<void>
export type ResolveOrderFulfillmentIssueResult = AxiosResponse<ResolveOrderFulfillmentIssue200>
