{"version":3,"sources":["../src/index.js"],"names":["message","rules","opts","valid","errors","warnings","undefined","parserOpts","parsed","missing","Object","keys","filter","name","length","names","RangeError","join","invalid","map","config","Array","isArray","Error","inspect","level","when","isNaN","item","i","results","entry","value","rule","Boolean","result"],"mappings":"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","file":"index.js","sourcesContent":["import util from 'util';\nimport isIgnored from '@commitlint/is-ignored';\nimport parse from '@commitlint/parse';\nimport implementations from '@commitlint/rules';\nimport entries from 'lodash.topairs';\n\nexport default async (message, rules = {}, opts = {}) => {\n\t// Found a wildcard match, skip\n\tif (isIgnored(message)) {\n\t\treturn {\n\t\t\tvalid: true,\n\t\t\terrors: [],\n\t\t\twarnings: []\n\t\t};\n\t}\n\n\t// Parse the commit message\n\tconst parsed = await parse(message, undefined, opts.parserOpts);\n\n\t// Find invalid rules configs\n\tconst missing = Object.keys(rules).filter(\n\t\tname => typeof implementations[name] !== 'function'\n\t);\n\n\tif (missing.length > 0) {\n\t\tconst names = Object.keys(implementations);\n\t\tthrow new RangeError(\n\t\t\t`Found missing rule names: ${missing.join(\n\t\t\t\t', '\n\t\t\t)}. Supported rule names are: ${names.join(', ')}`\n\t\t);\n\t}\n\n\tconst invalid = entries(rules)\n\t\t.map(([name, config]) => {\n\t\t\tif (!Array.isArray(config)) {\n\t\t\t\treturn new Error(\n\t\t\t\t\t`config for rule ${name} must be array, received ${util.inspect(\n\t\t\t\t\t\tconfig\n\t\t\t\t\t)} of type ${typeof config}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst [level, when] = config;\n\n\t\t\tif (typeof level !== 'number' || isNaN(level)) {\n\t\t\t\treturn new Error(\n\t\t\t\t\t`level for rule ${name} must be number, received ${util.inspect(\n\t\t\t\t\t\tlevel\n\t\t\t\t\t)} of type ${typeof level}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (level === 0 && config.length === 1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (config.length !== 2 && config.length !== 3) {\n\t\t\t\treturn new Error(\n\t\t\t\t\t`config for rule ${name} must be 2 or 3 items long, received ${util.inspect(\n\t\t\t\t\t\tconfig\n\t\t\t\t\t)} of length ${config.length}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (level < 0 || level > 2) {\n\t\t\t\treturn new RangeError(\n\t\t\t\t\t`level for rule ${name} must be between 0 and 2, received ${util.inspect(\n\t\t\t\t\t\tlevel\n\t\t\t\t\t)}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (typeof when !== 'string') {\n\t\t\t\treturn new Error(\n\t\t\t\t\t`condition for rule ${name} must be string, received ${util.inspect(\n\t\t\t\t\t\twhen\n\t\t\t\t\t)} of type ${typeof when}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (when !== 'never' && when !== 'always') {\n\t\t\t\treturn new Error(\n\t\t\t\t\t`condition for rule ${name} must be \"always\" or \"never\", received ${util.inspect(\n\t\t\t\t\t\twhen\n\t\t\t\t\t)}`\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t})\n\t\t.filter(item => item instanceof Error);\n\n\tif (invalid.length > 0) {\n\t\tthrow new Error(invalid.map(i => i.message).join('\\n'));\n\t}\n\n\t// Validate against all rules\n\tconst results = entries(rules)\n\t\t.filter(entry => {\n\t\t\tconst [, [level]] = entry;\n\t\t\treturn level > 0;\n\t\t})\n\t\t.map(entry => {\n\t\t\tconst [name, config] = entry;\n\t\t\tconst [level, when, value] = config;\n\n\t\t\t// Level 0 rules are ignored\n\t\t\tif (level === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst rule = implementations[name];\n\n\t\t\tconst [valid, message] = rule(parsed, when, value);\n\n\t\t\treturn {\n\t\t\t\tlevel,\n\t\t\t\tvalid,\n\t\t\t\tname,\n\t\t\t\tmessage\n\t\t\t};\n\t\t})\n\t\t.filter(Boolean);\n\n\tconst errors = results.filter(result => result.level === 2 && !result.valid);\n\tconst warnings = results.filter(\n\t\tresult => result.level === 1 && !result.valid\n\t);\n\n\tconst valid = errors.length === 0;\n\n\treturn {\n\t\tvalid,\n\t\terrors,\n\t\twarnings\n\t};\n};\n"]}