#!/usr/bin/env node
'use strict';

require('babel-polyfill'); // eslint-disable-line import/no-unassigned-import

var format = require('@commitlint/format');
var load = require('@commitlint/load');
var lint = require('@commitlint/lint');
var read = require('@commitlint/read');
var chalk = require('chalk');
var meow = require('meow');
var merge = require('lodash.merge');
var pick = require('lodash.pick');
var stdin = require('get-stdin');

var pkg = require('../package');
var help = require('./help');

var configuration = {
	string: ['cwd', 'from', 'to', 'edit', 'extends', 'parser-preset', 'config'],
	boolean: ['help', 'version', 'quiet', 'color'],
	alias: {
		c: 'color',
		d: 'cwd',
		e: 'edit',
		f: 'from',
		t: 'to',
		q: 'quiet',
		h: 'help',
		g: 'config',
		v: 'version',
		x: 'extends',
		p: 'parser-preset'
	},
	description: {
		color: 'toggle colored output',
		cwd: 'directory to execute in',
		config: 'path to the config file',
		edit: 'read last commit message from the specified file or fallbacks to ./.git/COMMIT_EDITMSG',
		extends: 'array of shareable configurations to extend',
		from: 'lower end of the commit range to lint; applies if edit=false',
		to: 'upper end of the commit range to lint; applies if edit=false',
		quiet: 'toggle console output',
		'parser-preset': 'configuration preset to use for conventional-commits-parser'
	},
	default: {
		color: true,
		cwd: process.cwd(),
		config: null,
		edit: false,
		from: null,
		to: null,
		quiet: false
	},
	unknown(arg) {
		throw new Error(`unknown flags: ${arg}`);
	}
};

var cli = meow({
	help: `[input] reads from stdin if --edit, --from and --to are omitted\n${help(configuration)}`,
	description: `${pkg.name}@${pkg.version} - ${pkg.description}`
}, configuration);

main(cli).catch(function (err) {
	return setTimeout(function () {
		if (err.type === pkg.name) {
			process.exit(1);
		}
		throw err;
	});
});

function main(options) {
	return new Promise(function ($return, $error) {
		var raw, flags, fromStdin, range, fmt, input, messages, err, loadOpts, loaded, parserOpts, opts;

		raw = options.input;
		flags = normalizeFlags(options.flags);
		fromStdin = checkFromStdin(raw, flags);

		range = pick(flags, 'edit', 'from', 'to');
		fmt = new chalk.constructor({ enabled: flags.color });

		return Promise.resolve(fromStdin ? stdin() : read(range, { cwd: flags.cwd })).then(function ($await_1) {
			try {
				input = $await_1;

				messages = (Array.isArray(input) ? input : [input]).filter(function (message) {
					return typeof message === 'string';
				}).filter(Boolean);

				if (messages.length === 0 && !checkFromRepository(flags)) {
					err = new Error('[input] is required: supply via stdin, or --edit or --from and --to');
					err.type = pkg.name;
					console.log(`${cli.help}\n`);
					console.log(err.message);
					return $error(err);
				}

				loadOpts = { cwd: flags.cwd, file: flags.config };
				return Promise.resolve(load(getSeed(flags), loadOpts)).then(function ($await_2) {
					try {
						loaded = $await_2;
						parserOpts = selectParserOpts(loaded.parserPreset);
						opts = parserOpts ? { parserOpts } : { parserOpts: {} };

						// Strip comments if reading from `.git/COMMIT_EDIT_MSG`
						if (range.edit) {
							opts.parserOpts.commentChar = '#';
						}

						return $return(Promise.all(messages.map(function (message) {
							return new Promise(function ($return, $error) {
								var report, formatted, error;
								return Promise.resolve(lint(message, loaded.rules, opts)).then(function ($await_3) {
									try {
										report = $await_3;
										formatted = format(report, { color: flags.color });

										if (!flags.quiet) {
											console.log(`${fmt.grey('â§—')}   input: ${fmt.bold(message.split('\n')[0])}`);
											console.log(formatted.join('\n'));
										}

										if (report.errors.length > 0) {
											error = new Error(formatted[formatted.length - 1]);
											error.type = pkg.name;
											return $error(error);
										}
										console.log('');
										return $return();
									} catch ($boundEx) {
										return $error($boundEx);
									}
								}.bind(this), $error);
							}.bind(this));
						})));
					} catch ($boundEx) {
						return $error($boundEx);
					}
				}.bind(this), $error);
			} catch ($boundEx) {
				return $error($boundEx);
			}
		}.bind(this), $error);
	}.bind(this));
}

function checkFromStdin(input, flags) {
	return input.length === 0 && !checkFromRepository(flags);
}

function checkFromRepository(flags) {
	return checkFromHistory(flags) || checkFromEdit(flags);
}

function checkFromEdit(flags) {
	return Boolean(flags.edit);
}

function checkFromHistory(flags) {
	return typeof flags.from === 'string' || typeof flags.to === 'string';
}

function normalizeFlags(flags) {
	// The `edit` flag is either a boolean or a string but we are only allowed
	// to specify one of them in minimist
	var edit = flags.edit === '' ? true : normalizeEdit(flags.edit);
	return merge({}, flags, { edit, e: edit });
}

function normalizeEdit(edit) {
	if (typeof edit === 'boolean') {
		return edit;
	}
	// The recommended method to specify -e with husky is commitlint -e $GIT_PARAMS
	// This does not work properly with win32 systems, where env variable declarations
	// use a different syntax
	// See https://github.com/marionebl/commitlint/issues/103 for details
	if (edit === '$GIT_PARAMS' || edit === '%GIT_PARAMS%') {
		if (!('GIT_PARAMS' in process.env)) {
			throw new Error(`Received ${edit} as value for -e | --edit, but GIT_PARAMS is not available globally.`);
		}
		return process.env.GIT_PARAMS;
	}
	return edit;
}

function getSeed(seed) {
	var e = Array.isArray(seed.extends) ? seed.extends : [seed.extends];
	var n = e.filter(function (i) {
		return typeof i === 'string';
	});
	return n.length > 0 ? { extends: n, parserPreset: seed.parserPreset } : { parserPreset: seed.parserPreset };
}

function selectParserOpts(parserPreset) {
	if (typeof parserPreset !== 'object') {
		return undefined;
	}

	if (typeof parserPreset.parserOpts !== 'object') {
		return undefined;
	}

	return parserPreset.parserOpts;
}

// Catch unhandled rejections globally
process.on('unhandledRejection', function (reason, promise) {
	console.log('Unhandled Rejection at: Promise ', promise, ' reason: ', reason);
	throw reason;
});
//# sourceMappingURL=cli.js.map