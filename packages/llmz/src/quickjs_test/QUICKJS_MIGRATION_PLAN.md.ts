export default "# QuickJS-Emscripten Migration Plan\n\n## Executive Summary\n\nThis document outlines a plan to replace the current dual VM execution system (isolated-vm + Node.js VM fallback) with quickjs-emscripten as a unified, cross-platform JavaScript sandbox for LLMz.\n\n## Current State Analysis\n\n### Existing VM Architecture (`src/vm.ts`)\n\n**Current Implementation:**\n- **Production/Default**: `isolated-vm` (Node.js only, native module)\n- **CI/Fallback**: Node.js built-in VM module\n- **Browser**: Basic JavaScript execution (no isolation)\n- **Driver Selection**: Environment-based (`VM_DRIVER` env var, `IS_CI` check)\n\n**Key Features:**\n- Memory limits (128MB for isolated-vm)\n- Context isolation with jail pattern\n- Property tracking and copying between host/sandbox\n- Support for getters/setters via references\n- Tool call tracking and variable extraction\n- JSX component yielding\n- Timeout support (60s default)\n- Source map integration for error handling\n- Two-way context synchronization\n\n**Current Pain Points:**\n1. **Platform Fragmentation**: Different execution paths for Node.js, CI, and browser\n2. **Native Dependency**: isolated-vm requires native compilation\n3. **Complexity**: ~667 lines managing two different VM implementations\n4. **Browser Limitations**: No true isolation in browser environments\n5. **CI Compatibility**: isolated-vm doesn't work well in CI, requires fallback\n6. **Installation Issues**: Native module compilation can fail\n\n## Why QuickJS-Emscripten?\n\n### Key Benefits\n\n1. **Universal Platform Support**\n   - Works in Node.js, browsers, Deno, Bun, and other JavaScript runtimes\n   - No native compilation required (WebAssembly-based)\n   - Single codebase for all platforms\n\n2. **True Isolation Everywhere**\n   - Sandboxed execution in both browser and Node.js\n   - WebAssembly provides consistent security guarantees\n   - No risk of accessing host system resources\n\n3. **Smaller Bundle Size**\n   - Minimal setup: ~1.3MB total (quickjs-emscripten-core + WASM file)\n   - Much smaller than isolated-vm's native binary\n   - Tree-shakeable, ESM-native\n\n4. **Better Developer Experience**\n   - No native build toolchain required\n   - Works out-of-the-box in CI environments\n   - Package.json export conditions for ESM/CJS\n\n5. **Advanced Features**\n   - ASYNCIFY support for async/await in sandbox\n   - Memory limits and resource control\n   - Interrupt handlers for timeout support\n   - Multiple build variants (debug/release)\n\n6. **Active Maintenance**\n   - Actively maintained project\n   - Regular updates and bug fixes\n   - Good documentation and examples\n\n### Trade-offs\n\n**Potential Limitations:**\n1. **Performance**: QuickJS may be slower than V8 (isolated-vm), but likely faster than Node.js VM\n2. **API Compatibility**: Need to verify ES2020+ feature support in QuickJS\n3. **Memory Overhead**: WebAssembly adds some overhead vs. native\n4. **Learning Curve**: Team needs to learn new API\n\n**Mitigations:**\n- LLMz code generation is typically simple (loops, conditionals, tool calls)\n- Performance bottleneck is LLM generation, not code execution\n- QuickJS supports ES2020, sufficient for generated code\n- Clear migration path with comprehensive testing\n\n## Migration Architecture\n\n### Target Architecture\n\n```typescript\n// Unified driver using quickjs-emscripten\nimport { getQuickJS } from 'quickjs-emscripten'\n\nexport async function runAsyncFunction(\n  context: any,\n  code: string,\n  traces: Trace[] = [],\n  signal: AbortSignal | null = null,\n  timeout: number = MAX_VM_EXECUTION_TIME\n): Promise<VMExecutionResult> {\n  const QuickJS = await getQuickJS()\n  const runtime = QuickJS.newRuntime()\n  const vm = runtime.newContext()\n\n  try {\n    // Set memory limit (equivalent to isolated-vm's 128MB)\n    runtime.setMemoryLimit(128 * 1024 * 1024)\n\n    // Set interrupt handler for timeout support\n    runtime.setInterruptHandler(() => {\n      return signal?.aborted || Date.now() - startTime > timeout\n    })\n\n    // Execute code in sandbox\n    const result = vm.evalCode(code)\n\n    return processResult(result)\n  } finally {\n    vm.dispose()\n    runtime.dispose()\n  }\n}\n```\n\n### Key Implementation Changes\n\n#### 1. Context Bridging\n\n**Current (isolated-vm):**\n- Manual property copying with `jail.set()`\n- Separate handling for functions, objects, primitives\n- Complex getter/setter reference tracking\n- Two-way synchronization after execution\n\n**Target (quickjs-emscripten):**\n- Use `vm.newFunction()` to expose host functions\n- `vm.newObject()` + `vm.setProp()` for objects\n- Automatic handle management with `Scope.withScope()`\n- Simpler one-way data flow with explicit exports\n\n#### 2. Tool Call Interception\n\n**Current:**\n```typescript\nawait isolatedContext.evalClosure(\n  `global['${key}'] = (...args) => $0.applySyncPromise(null, args, {arguments: {copy: true}});`,\n  [async (...args: any[]) => new isolatedVm.ExternalCopy(await context[key](...args)).copyInto()]\n)\n```\n\n**Target:**\n```typescript\nconst toolHandle = vm.newFunction(key, async (...args) => {\n  const result = await context[key](...args)\n  return vm.unwrapResult(result)\n})\nvm.setProp(vm.global, key, toolHandle)\ntoolHandle.dispose()\n```\n\n#### 3. Variable Tracking\n\n**Current:**\n- Line tracking via injected function calls\n- Variable extraction through AST plugins\n- Top-level property tracking with `__report`\n\n**Target:**\n- Same AST-based approach (no changes to compiler)\n- Simplified context extraction using `vm.getProp()`\n- More efficient value marshaling with QuickJS handles\n\n#### 4. Error Handling\n\n**Current:**\n- Stack trace parsing for `<isolated-vm>` or `<anonymous>`\n- Source map integration for original line numbers\n- Manual offset calculations (LINE_OFFSET = 3 or 1)\n\n**Target:**\n- Parse QuickJS stack traces (format: `at <eval> (...)`)\n- Same source map integration (unchanged)\n- Simpler offset calculations (consistent format)\n\n#### 5. Async/Yield Support\n\n**Current:**\n- Wrapped code in async generator function\n- Manual `do/while` loop for yielding\n- Different implementations for isolated-vm vs Node.js VM\n\n**Target:**\n- Use ASYNCIFY build variant for async support\n- Same async generator wrapper pattern\n- Unified implementation across all platforms\n\n## Migration Plan\n\n### Phase 1: Proof of Concept (Week 1)\n\n**Goals:**\n- Validate quickjs-emscripten can execute LLMz-generated code\n- Test core features: tools, variables, JSX yielding\n- Measure performance vs. current implementation\n\n**Tasks:**\n1. Create `src/vm-quickjs.test.ts` with existing test cases\n2. Implement minimal `runAsyncFunctionQuickJS()` prototype\n3. Test with examples: `11_worker_minimal`, `16_worker_tool_chaining`\n4. Benchmark execution time vs. isolated-vm\n5. Document any compatibility issues\n\n**Success Criteria:**\n- All core VM tests pass with quickjs-emscripten\n- Performance within 2x of isolated-vm\n- No major compatibility blockers identified\n\n### Phase 2: Feature Parity Implementation (Week 2-3)\n\n**Goals:**\n- Implement all current VM features\n- Achieve 100% test coverage parity\n- Handle edge cases and error scenarios\n\n**Tasks:**\n\n#### 2.1 Core Execution\n- [ ] Implement context setup with tool/object bridging\n- [ ] Add memory limit configuration (128MB default)\n- [ ] Implement timeout with interrupt handlers\n- [ ] Support AbortSignal integration\n- [ ] Handle primitive, object, and function context values\n\n#### 2.2 Variable Tracking\n- [ ] Integrate variable extraction (reuse compiler plugins)\n- [ ] Implement `VariableTrackingFnIdentifier` bridge\n- [ ] Support getter/setter tracking\n- [ ] Copy back modified variables after execution\n- [ ] Handle sealed and non-extensible objects\n\n#### 2.3 Tool System Integration\n- [ ] Bridge tool functions from context\n- [ ] Support async tool calls with ASYNCIFY\n- [ ] Implement `ToolCallTrackerFnIdentifier` for snapshot support\n- [ ] Handle tool call errors and retry logic\n- [ ] Track tool call assignments for snapshots\n\n#### 2.4 Component/JSX System\n- [ ] Implement `JSXFnIdentifier` bridge\n- [ ] Support async generator yielding (`AsyncIterYieldFnIdentifier`)\n- [ ] Handle component validation and rendering\n- [ ] Test multi-component yielding\n\n#### 2.5 Error Handling\n- [ ] Parse QuickJS stack traces\n- [ ] Integrate source map for line mapping\n- [ ] Generate annotated error code (arrow pointers)\n- [ ] Preserve error context and variables\n- [ ] Handle VMSignal errors (SnapshotSignal, ThinkSignal)\n\n#### 2.6 Tracing System\n- [ ] Implement comment tracing (`CommentFnIdentifier`)\n- [ ] Support line execution tracking\n- [ ] Add console.log tracing (`ConsoleObjIdentifier`)\n- [ ] Track yield operations\n- [ ] Maintain trace timestamps\n\n**Success Criteria:**\n- All existing `src/vm.test.ts` tests pass\n- All 28 examples run successfully\n- Error messages are as informative as current implementation\n- Feature parity checklist 100% complete\n\n### Phase 3: Integration & Testing (Week 4)\n\n**Goals:**\n- Replace current VM implementation\n- Comprehensive testing across all platforms\n- Performance validation\n\n**Tasks:**\n\n#### 3.1 Code Integration\n- [ ] Create feature flag: `USE_QUICKJS` env variable\n- [ ] Refactor `vm.ts` to use quickjs-emscripten\n- [ ] Remove isolated-vm and Node.js VM code paths\n- [ ] Update type definitions and exports\n- [ ] Clean up legacy driver detection code\n\n#### 3.2 Cross-Platform Testing\n- [ ] Test in Node.js (v18, v20, v22)\n- [ ] Test in browsers (Chrome, Firefox, Safari)\n- [ ] Test in CI environments (GitHub Actions)\n- [ ] Test in Deno (if supported)\n- [ ] Test in Bun (if supported)\n\n#### 3.3 Example Testing\n- [ ] Run all 20 examples with QuickJS VM\n- [ ] Test chat mode examples (01-10, 20)\n- [ ] Test worker mode examples (11-19)\n- [ ] Verify snapshots work correctly\n- [ ] Test error recovery scenarios\n\n#### 3.4 Performance Testing\n- [ ] Benchmark code execution time\n- [ ] Measure memory usage\n- [ ] Test timeout handling\n- [ ] Profile WASM initialization overhead\n- [ ] Compare vs. baseline (isolated-vm + Node.js VM)\n\n**Success Criteria:**\n- All tests pass on all platforms\n- Examples run without modification\n- Performance within acceptable range (<2x slower)\n- No regressions in functionality\n\n### Phase 4: Optimization & Polish (Week 5)\n\n**Goals:**\n- Optimize performance bottlenecks\n- Improve error messages\n- Documentation updates\n\n**Tasks:**\n\n#### 4.1 Performance Optimization\n- [ ] Cache QuickJS module initialization\n- [ ] Optimize context setup (reduce bridge calls)\n- [ ] Use RELEASE_SYNC build variant for production\n- [ ] Minimize handle creation/disposal overhead\n- [ ] Profile and optimize hot paths\n\n#### 4.2 Developer Experience\n- [ ] Improve error messages and stack traces\n- [ ] Add debug mode with detailed logging\n- [ ] Create migration guide for users\n- [ ] Update CLAUDE.md with QuickJS details\n- [ ] Add troubleshooting section to docs\n\n#### 4.3 Build Configuration\n- [ ] Configure build variants (debug/release)\n- [ ] Optimize bundle size for browser\n- [ ] Set up source maps for debugging\n- [ ] Configure ESM/CJS dual package\n- [ ] Test tree-shaking effectiveness\n\n#### 4.4 Documentation\n- [ ] Update README.md with platform support\n- [ ] Document QuickJS configuration options\n- [ ] Add quickjs-emscripten to dependencies section\n- [ ] Update STRUCTURE.md with new architecture\n- [ ] Create QUICKJS_MIGRATION.md guide\n\n**Success Criteria:**\n- Performance optimized to <1.5x isolated-vm\n- Clear documentation for troubleshooting\n- All docs updated to reflect changes\n- Build artifacts optimized for size\n\n### Phase 5: Rollout & Monitoring (Week 6)\n\n**Goals:**\n- Gradual rollout to production\n- Monitor for issues\n- Gather feedback\n\n**Tasks:**\n\n#### 5.1 Gradual Rollout\n- [ ] Deploy with feature flag (default: OFF)\n- [ ] Enable for 10% of traffic\n- [ ] Monitor error rates and performance\n- [ ] Increase to 50% if stable\n- [ ] Full rollout if no issues\n\n#### 5.2 Monitoring\n- [ ] Track execution time metrics\n- [ ] Monitor error rates\n- [ ] Watch for memory leaks\n- [ ] Alert on timeout increases\n- [ ] Collect user feedback\n\n#### 5.3 Cleanup\n- [ ] Remove isolated-vm dependency\n- [ ] Delete legacy VM code\n- [ ] Archive old tests (if needed)\n- [ ] Update package.json\n- [ ] Remove `VM_DRIVER` env variable\n\n**Success Criteria:**\n- Zero critical bugs reported\n- Performance meets SLAs\n- Positive user feedback\n- Legacy code fully removed\n\n## Implementation Details\n\n### Package Changes\n\n**Add:**\n```json\n{\n  \"dependencies\": {\n    \"quickjs-emscripten\": \"^0.29.0\"\n  }\n}\n```\n\n**Remove:**\n```json\n{\n  \"dependencies\": {\n    \"isolated-vm\": \"^5.0.3\"\n  }\n}\n```\n\n**Net Change:** ~15MB smaller package size (no native binaries)\n\n### API Surface Changes\n\n**Public API:** No changes (internal implementation only)\n**Environment Variables:**\n- Remove: `VM_DRIVER`\n- Add: `QUICKJS_VARIANT` (optional: 'debug' | 'release-sync', default: 'release-sync')\n\n### File Changes\n\n**Modified:**\n- `src/vm.ts` - Complete rewrite (~400 lines vs. 667)\n- `src/vm.test.ts` - Update test assertions for QuickJS\n- `package.json` - Swap dependencies\n\n**Added:**\n- `src/vm-quickjs-bridge.ts` - Context bridging utilities (optional, for organization)\n\n**Removed:**\n- None (isolated-vm code will be deleted from vm.ts)\n\n## Risk Assessment\n\n### High-Risk Items\n1. **Breaking Changes**: Subtle behavior differences in QuickJS vs. V8\n   - **Mitigation**: Comprehensive test suite, gradual rollout\n\n2. **Performance Regression**: Slower execution impacts user experience\n   - **Mitigation**: Benchmarking, optimization phase, acceptable threshold\n\n3. **Feature Gaps**: QuickJS missing required JS features\n   - **Mitigation**: POC phase validates compatibility, fallback plan\n\n### Medium-Risk Items\n1. **Memory Leaks**: Improper handle disposal in QuickJS\n   - **Mitigation**: Use `Scope.withScope()`, rigorous testing\n\n2. **WASM Loading**: Initialization time impacts cold starts\n   - **Mitigation**: Lazy loading, module caching, measure impact\n\n3. **Browser Compatibility**: WASM not supported in old browsers\n   - **Mitigation**: Document minimum browser versions, acceptable trade-off\n\n### Low-Risk Items\n1. **Build Process**: WASM files need bundler configuration\n   - **Mitigation**: Most bundlers work out-of-box, document exceptions\n\n2. **Debugging**: Stack traces may be less familiar\n   - **Mitigation**: Improve error messages, debug build variant\n\n## Rollback Plan\n\nIf critical issues arise:\n\n1. **Immediate (< 1 hour):**\n   - Flip feature flag to disable QuickJS\n   - Keep isolated-vm code during rollout phase\n   - No code changes needed\n\n2. **Short-term (< 1 day):**\n   - Revert package.json changes\n   - Restore isolated-vm dependency\n   - Git revert VM changes\n\n3. **Long-term:**\n   - Re-evaluate quickjs-emscripten vs. alternatives\n   - Consider hybrid approach (QuickJS for browser only)\n   - Keep current architecture if no viable alternative\n\n## Success Metrics\n\n### Performance\n- **Target:** <1.5x execution time vs. isolated-vm\n- **Acceptable:** <2.0x execution time\n- **Unacceptable:** >2.0x execution time\n\n### Reliability\n- **Target:** Zero critical bugs, <0.1% error rate increase\n- **Acceptable:** <3 critical bugs, <0.5% error rate increase\n- **Unacceptable:** >3 critical bugs or >1% error rate increase\n\n### Platform Support\n- **Target:** Works on Node.js, Chrome, Firefox, Safari, CI\n- **Acceptable:** Works on Node.js and modern browsers\n- **Unacceptable:** Doesn't work on Node.js or major browsers\n\n### Bundle Size\n- **Target:** <1.5MB increase in browser bundle\n- **Acceptable:** <3MB increase\n- **Unacceptable:** >3MB increase\n\n## Timeline\n\n| Phase | Duration | Start Date | End Date |\n|-------|----------|------------|----------|\n| Phase 1: POC | 1 week | Week 1 | Week 1 |\n| Phase 2: Implementation | 2 weeks | Week 2 | Week 3 |\n| Phase 3: Integration | 1 week | Week 4 | Week 4 |\n| Phase 4: Optimization | 1 week | Week 5 | Week 5 |\n| Phase 5: Rollout | 1 week | Week 6 | Week 6 |\n| **Total** | **6 weeks** | | |\n\n## Open Questions\n\n1. **ASYNCIFY Performance**: Does ASYNCIFY add significant overhead for async/await?\n2. **Module System**: Does QuickJS support ES modules, or only CommonJS?\n3. **Debugging**: What debugging tools are available for QuickJS?\n4. **Memory Limits**: Can we enforce stricter memory limits than 128MB?\n5. **Interrupt Granularity**: How frequently does interrupt handler get called?\n\n**Resolution:** Investigate during POC phase (Phase 1)\n\n## Conclusion\n\nMigrating to quickjs-emscripten offers significant benefits:\n- **Universal platform support** (Node.js, browser, CI)\n- **Simpler architecture** (single VM implementation)\n- **Better DX** (no native compilation)\n- **Smaller bundle size** (~15MB savings)\n- **True isolation everywhere** (security improvement)\n\nThe migration is feasible with acceptable risk, clear phases, and measurable success criteria. The 6-week timeline provides buffer for unexpected issues while maintaining momentum.\n\n**Recommendation:** Proceed with Phase 1 (POC) to validate feasibility and gather data for go/no-go decision.\n"