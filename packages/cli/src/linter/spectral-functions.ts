import { IFunctionResult, RulesetFunctionContext } from '@stoplight/spectral-core'
import type { JsonPath } from '@stoplight/types'
import { JSONPath } from 'jsonpath-plus'

type MessageFn = ({ path, isFallback }: { path: (string | number)[]; isFallback: boolean }) => string

const isFalsy = (input: string): boolean => {
  return !input
}

/**
 * When the input is falsy, return a message that is generated by the provided function
 */
export const truthyWithMessage = (fn: MessageFn) => (input: string, _: unknown, context: RulesetFunctionContext) => {
  const messages: IFunctionResult[] = []

  if (isFalsy(input)) {
    const message = fn({ path: context.path, isFallback: false })
    messages.push({ message })
  }

  return messages
}

type FallbackResult = { path: JsonPath; value: string } | null

/** Extracts a fallback result that will be tested for truthyness */
type FallbackExtractor = (
  failedPath: JsonPath,
  jsonPathExtractor: (fallbackGiven: string) => { resolvedPath: JsonPath; value: any }[]
) => FallbackResult

const _parseJsonPathPointer = (pointer: string): JsonPath => {
  return pointer
    .replace(/^\//, '')
    .split('/')
    .map((segment: string) => {
      // Do not use "parseInt" here
      const numOrNan = Number(segment)
      return isNaN(numOrNan) ? segment : numOrNan
    })
}

// This is safer than `"key" in obj` when
// dealing with an unknown/any variable
const _safeHasProp = (obj: unknown, key: string) => {
  return {}.hasOwnProperty.call(obj ?? {}, key)
}

// The logic in this function will eventully replace `truthyWithMessage`
export const isTruthyElseFailMessage =
  (
    failMsgSupplier: MessageFn,
    options: {
      fallbackExtractor?: FallbackExtractor
    }
  ) =>
  (input: string, _: unknown, context: RulesetFunctionContext) => {
    const messages: IFunctionResult[] = []

    if (!isFalsy(input)) {
      return messages
    }

    if (!options.fallbackExtractor) {
      const message = failMsgSupplier({ path: context.path, isFallback: false })
      messages.push({ message })
    } else {
      const { path, document } = context
      const jsonPathExtractor = (fallbackGiven: string) => {
        const jsonSchema = document.data
        const output = JSONPath({ path: fallbackGiven, json: jsonSchema as object, resultType: 'all' }) as any[]

        // There is a "path" property, but it's serialized and is harder to parse than "pointer"
        if (!output.every((result) => _safeHasProp(result, 'value') && _safeHasProp(result, 'pointer'))) {
          throw new Error("Fallback JSONPath output is missing either one or both the 'value' or 'pointer' property")
        }

        return output.map((result) => {
          const resolvedPath = _parseJsonPathPointer(result.pointer)
          return { resolvedPath, value: result.value }
        })
      }

      try {
        const fallbackResult = options.fallbackExtractor(path, jsonPathExtractor)
        if (fallbackResult === null || isFalsy(fallbackResult.value)) {
          const isFallback = fallbackResult !== null
          const resolvedPath = isFallback ? fallbackResult.path : path

          if (!Array.isArray(resolvedPath)) {
            throw new Error('The resolved path was not provided')
          }

          const message = failMsgSupplier({ path: resolvedPath, isFallback })
          messages.push({ message })
        }
      } catch (thrown: unknown) {
        const error = thrown instanceof Error ? thrown : new Error(String(thrown))
        console.error(`Ruleset failed in either the fallback extractor or the message supplier -> ${error.message}`)
      }
    }

    return messages
  }
