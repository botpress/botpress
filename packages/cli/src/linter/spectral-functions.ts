import { IFunctionResult, RuleDefinition, RulesetFunctionContext } from '@stoplight/spectral-core'
import type { JsonPath } from '@stoplight/types'
import { JSONPath } from 'jsonpath-plus'
import { Logger } from '../logger'

type SpectralDocument = RulesetFunctionContext['document']
type RulesetThenFn = Exclude<RuleDefinition['then'], Array<any>>['function']

type MessageFn = ({ path, isFallback }: { path: (string | number)[]; isFallback: boolean }) => string
type TruthyWithMessageOptions = {
  failMsgSupplier: MessageFn
  fallbackExtractor: FallbackExtractor
}

/** Extracts a fallback result that will be tested for truthyness */
type FallbackExtractor = (
  failedPath: JsonPath,
  jsonPathExtractor: (fallbackGiven: string) => { resolvedPath: JsonPath; value: any }[]
) => { path: JsonPath; value: string } | null

/**
 * When the input is falsy, return a message that is generated by the provided function
 *
 * @remark When using the `fallbackExtractor`, it's expected to use a portion
 *  of the resolved path so the fallback query continues from that point.
 */
export function truthyWithMessage(failMsgSupplier: MessageFn): RulesetThenFn
export function truthyWithMessage(options: TruthyWithMessageOptions): RulesetThenFn
export function truthyWithMessage(failMsgSupplierOrOptions: MessageFn | TruthyWithMessageOptions): RulesetThenFn {
  const { failMsgSupplier, fallbackExtractor } =
    typeof failMsgSupplierOrOptions === 'function'
      ? { failMsgSupplier: failMsgSupplierOrOptions }
      : failMsgSupplierOrOptions

  return (input: string, _: unknown, context: RulesetFunctionContext) => {
    const messages: IFunctionResult[] = []

    if (!_isFalsy(input)) {
      return messages
    }

    const { path } = context
    if (!fallbackExtractor) {
      const message = failMsgSupplier({ path, isFallback: false })
      messages.push({ message })
    } else {
      const jsonPathFn = _extractJsonPath.bind(null, context.document)
      try {
        const fallbackResult = fallbackExtractor(path, jsonPathFn)
        if (fallbackResult === null || _isFalsy(fallbackResult.value)) {
          const isFallback = fallbackResult !== null
          const resolvedPath = isFallback ? fallbackResult.path : path

          if (!Array.isArray(resolvedPath)) {
            // This is likely due to a mistake in the fallbackExtractor,
            // which is easy to make since there are "any" types involved
            throw new Error('The resolved path was not provided or is invalid')
          }

          const message = failMsgSupplier({ path: resolvedPath, isFallback })
          messages.push({ message })
        }
      } catch (thrown: unknown) {
        const error = thrown instanceof Error ? thrown : new Error(String(thrown))
        new Logger().error(
          `Ruleset failed in either the fallback extractor or the message supplier -> ${error.message}`
        )
      }
    }

    return messages
  }
}

const _isFalsy = (input: string): boolean => {
  return !input
}

/** Parses the equivalent of Stoplight's JsonPath from the JsonPath-plus "pointer" output */
const _parseJsonPathPointer = (pointer: string): JsonPath => {
  return pointer
    .replace(/^\//, '')
    .split('/')
    .map((segment: string) => {
      // Do not use "parseInt" here
      const numOrNan = Number(segment)
      return isNaN(numOrNan) ? segment : numOrNan
    })
}

// This is safer than `"key" in obj` when
// dealing with an unknown/any variable
const _safeHasProp = (obj: unknown, key: string) => {
  return {}.hasOwnProperty.call(obj ?? {}, key)
}

const _extractJsonPath = (schemaDocument: SpectralDocument, fallbackJsonPath: string) => {
  const output = JSONPath({
    path: fallbackJsonPath,
    json: schemaDocument.data as object,
    resultType: 'all',
  }) as any[]

  // There is a "path" property, but it's serialized in a way that is harder to parse than "pointer"
  if (!output.every((result) => _safeHasProp(result, 'value') && _safeHasProp(result, 'pointer'))) {
    throw new Error("Fallback JSONPath output is missing either one or both the 'value' or 'pointer' property")
  }

  return output.map((result) => {
    const resolvedPath = _parseJsonPathPointer(result.pointer)
    return { resolvedPath, value: result.value }
  })
}
